---
import { getModels } from '../lib/supabase';
import Header from '../components/Header.astro';



const models = await getModels();

function formatScore(score: string | number | null) {
  if (score === null || score === undefined) return '—';
  const num = Number(score);
  if (!isFinite(num) || num <= 0) return '—';
  const pct = num <= 1 ? num * 100 : num;
  return `${pct.toFixed(1)}%`;
}

const validModels = models.filter((model: any) => {
  const inputPrice = Number(model.price_1m_input_tokens);
  const outputPrice = Number(model.price_1m_output_tokens);
  return inputPrice > 0 && outputPrice > 0;
});

const selectedModels = validModels.slice(0, 3);

const getWinner = (items: any[], key: string, isLowerBetter = false) => {
  const usable = items.filter(m => Number(m[key]) > 0);
  if (usable.length === 0) return null;
  return usable.sort((a, b) => {
    const valA = Number(a[key]);
    const valB = Number(b[key]);
    return isLowerBetter ? valA - valB : valB - valA;
  })[0];
};

const inputPriceWinner = getWinner(selectedModels, 'price_1m_input_tokens', true);
const outputPriceWinner = getWinner(selectedModels, 'price_1m_output_tokens', true);
const performanceWinner = getWinner(selectedModels, 'mmlu_pro');
const tpsWinner = getWinner(selectedModels, 'median_output_tokens_per_second');
const ttftWinner = getWinner(selectedModels, 'median_time_to_first_answer_token', true);

const getCheapestTokensModel = () => {
  if (selectedModels.length === 0) return null;
  const modelsWithBlendedPrice = selectedModels.filter(model => {
    const blendedPrice = model.price_1m_blended_3_to_1;
    const priceNum = Number(blendedPrice);
    return blendedPrice !== null && blendedPrice !== undefined && !isNaN(priceNum) && priceNum > 0;
  });
  if (modelsWithBlendedPrice.length === 0) return null;
  
  console.log('Models with blended price:', modelsWithBlendedPrice.map(m => ({ name: m.name, price: m.price_1m_blended_3_to_1 })));
  
  const sorted = modelsWithBlendedPrice.sort((a, b) => {
    const priceA = Number(a.price_1m_blended_3_to_1);
    const priceB = Number(b.price_1m_blended_3_to_1);
    console.log(`Comparing ${a.name} ($${priceA}) vs ${b.name} ($${priceB})`);
    return priceA - priceB; // Lower price is better
  });
  
  console.log('Cheapest tokens model:', sorted[0].name, 'with blended price:', sorted[0].price_1m_blended_3_to_1);
  return sorted[0];
};

const cheapestTokensModel = getCheapestTokensModel();

// Dynamic benchmark mapping from database fields
const availableBenchmarks = {
  'mmlu_pro': 'MMLU Pro',
  'gpqa': 'GPQA',
  'hle': 'HumanEval',
  'aa_math_index': 'Math Index',
  'aa_coding_index': 'Coding Index',
  'aa_intelligence_index': 'Intelligence Index',
  'livecodebench': 'LiveCodeBench',
  'scicode': 'SciCode',
  'math_500': 'Math 500',
  'aime': 'AIME',
  'elo': 'ELO Rating'
};
---
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>AI Stats – Compare Models</title>
    <link rel="stylesheet" href="/fonts/nebula sans/nebula-sans.css" />
    <style>
      :root {
        --surface-0: #000100;
        --text-primary: #F8F8F8;
        --glass: rgba(255, 255, 255, 0.05);
        --accent: #8b5cf6;
      }
      .bar-stack-duo { height: 170px; width: 100%; display: flex; align-items: flex-end; justify-content: center; gap: 2px; }
      .bar-stack { height: 200px; width: 100%; display: flex; align-items: flex-end; justify-content: center; }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: var(--surface-0);
        color: var(--text-primary);
        font-family: 'Nebula Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 1.6;
      }
      .glass-nav {
        background: var(--glass);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        position: sticky;
        top: 0;
        z-index: 50;
      }
      .nav-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.5rem;
        max-width: 1200px;
        margin: 0 auto;
      }
      .nav-links {
        display: flex;
        gap: 1rem;
      }
      .nav-link {
        color: rgba(161, 166, 180, 0.8);
        text-decoration: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        transition: all 0.3s ease;
      }
      .nav-link:hover,
      .nav-link.active {
        color: var(--accent);
        background: rgba(139, 92, 246, 0.15);
      }
      .layout {
        display: flex;
        gap: 0;
        max-width: 100%;
        margin: 0;
        padding: 0;
        align-items: flex-start;
        box-sizing: border-box;
        width: 100%;
        min-height: 100vh;
        position: relative;
        overflow-x: hidden; /* Prevent horizontal overflow */
      }
      .smart-filter-rail {
        width: 280px;
        min-width: 280px;
        flex-shrink: 0;
        background: rgba(0, 1, 0, 0.95);
        backdrop-filter: blur(20px);
        border-right: 1px solid rgba(255, 255, 255, 0.1);
        padding: 2rem 1.5rem;
        padding-top: 1.5rem; /* Increased padding to push content below header */
        height: 100vh; /* Full viewport height */
        overflow-y: auto;
        position: fixed;
        top: 0;
        left: 0;
        z-index: 40;
        transform: translateX(0);
        transition: transform 0.3s ease;
      }
      
      /* Add more space for the first element in the sidebar */
      .smart-filter-rail > *:first-child {
        margin-top: 1.5rem;
      }
      
      .smart-filter-rail.closed {
        transform: translateX(-100%);
      }
      @media (max-width: 800px) {
        .layout {
          flex-direction: column;
          padding: 0;
        }
        .smart-filter-rail {
          position: fixed;
          top: 0;
          left: 0;
          bottom: 0;
          width: 85%;
          max-width: 320px;
          transform: translateX(-100%);
          z-index: 55;
          overflow-y: auto;
          background: rgba(0, 1, 0, 0.95);
          backdrop-filter: blur(20px);
          border-right: 1px solid rgba(255, 255, 255, 0.1);
          box-shadow: 0 4px 32px rgba(0,0,0,0.6);
          height: 100vh;
          padding: 1rem 1.5rem;
          padding-top: 5rem; /* Adjusted padding for mobile */
          transition: transform 0.3s ease;
        }
        .smart-filter-rail.open {
          transform: translateX(0);
        }
        .compare-main {
          margin: 0;
          padding: 1rem;
          max-width: 100%;
          width: 100%;
        }
        .chart-grid {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 1.5rem;
          width: 100%;
        }
        .chart-section {
          width: 100%;
          max-width: 500px;
          margin: 0 auto 1.5rem auto;
          padding: 1rem;
        }
        .chart-container {
          /* For Chart.js canvas, use block layout */
          display: block;
          padding: 1.5rem 0.5rem 1rem 0.5rem;
          height: 360px; /* explicit height so canvas can size */
          width: 100%;
          overflow: hidden;
          scrollbar-width: thin;
          scrollbar-color: var(--accent) rgba(0, 0, 0, 0.2);
          position: relative;
        }
        /* Make canvases fill container */
        #price-canvas, #perf-canvas {
          display: block;
          width: 100% !important;
          height: 100% !important;
        }
        
        .chart-container::-webkit-scrollbar {
          height: 6px;
        }
        
        .chart-container::-webkit-scrollbar-track {
          background: rgba(0, 0, 0, 0.2);
          border-radius: 3px;
        }
        
        .chart-container::-webkit-scrollbar-thumb {
          background-color: var(--accent);
          border-radius: 3px;
        }
        .chart-item {
          display: flex;
          flex-direction: column;
          align-items: center;
          flex: 1;
          min-width: 50px;
          max-width: 70px;
        }
        .filter-toggle {
          display: block;
        }
      }
      .filter-section {
        margin-bottom: 1.5rem;
      }
      .filter-section h3 {
        margin-bottom: 0.5rem;
        font-size: 1rem;
      }
      .model-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-height: 300px;
        overflow-y: auto;
      }
      .model-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .compare-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2rem;
        min-width: 0;
        width: calc(100% - 280px);
        margin-left: 280px;
        padding: 2rem;
        box-sizing: border-box;
        max-width: 100%;
        overflow-x: hidden; /* Prevent horizontal overflow */
      }
      .chart-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 2rem;
        width: 100%;
        max-width: 1200px;
        margin: 0 auto;
      }
      .chart-card {
        background: var(--glass);
        border-radius: 8px;
        padding: 1rem;
      }
      .chart-section {
        background: var(--glass);
        border-radius: 12px;
        padding: 2rem;
        border: 1px solid rgba(161, 166, 180, 0.1);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        width: 100%;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .chart-section:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
      }
      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
      }
      .chart-header h3 {
        margin: 0;
        font-size: 1.2rem;
        font-weight: 600;
        color: #F8F8F8;
      }
      
      .zoom-button {
        background: var(--glass);
        color: var(--accent);
        border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 4px;
        padding: 0.25rem 0.75rem;
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      
      .zoom-button:hover {
        background: rgba(139, 92, 246, 0.15);
        border-color: var(--accent);
      }
      
      .zoom-button.active {
        background: rgba(139, 92, 246, 0.25);
        border-color: var(--accent);
      }
      .chart-container {
        display: block;
        width: 100%;
        height: 360px;
        overflow: hidden;
        background: linear-gradient(180deg, rgba(10, 10, 11, 0.4) 0%, rgba(10, 10, 11, 0.8) 100%);
        border-radius: 8px;
        padding: 1rem;
        border: 1px solid rgba(161, 166, 180, 0.1);
        position: relative;
        margin: 0 auto;
        scrollbar-width: thin;
      }
      .chart-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 72px;
        position: relative;
        flex: none;
      }
      .chart-bar {
        width: 100%;
        min-width: 40px;
        border-radius: 12px;
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        margin-top: auto;
        background: rgba(75, 123, 236, 0.25);
        backdrop-filter: blur(20px) saturate(1.2);
        -webkit-backdrop-filter: blur(20px) saturate(1.2);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 
          0 8px 32px rgba(0, 0, 0, 0.15),
          0 2px 8px rgba(0, 0, 0, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.3),
          inset 0 -1px 0 rgba(0, 0, 0, 0.1);
        display: block;
        opacity: 1;
        visibility: visible;
        overflow: hidden;
      }
      
      .chart-bar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, 
          rgba(255, 255, 255, 0.2) 0%, 
          rgba(255, 255, 255, 0.1) 30%, 
          rgba(255, 255, 255, 0.02) 70%, 
          rgba(0, 0, 0, 0.05) 100%);
        border-radius: inherit;
        pointer-events: none;
        opacity: 0.8;
      }
      
      .chart-bar::after {
        content: '';
        position: absolute;
        top: 1px;
        left: 1px;
        right: 1px;
        height: 30%;
        background: linear-gradient(180deg, 
          rgba(255, 255, 255, 0.15) 0%, 
          rgba(255, 255, 255, 0.05) 50%, 
          transparent 100%);
        border-radius: 10px 10px 0 0;
        pointer-events: none;
      }
      .chart-bar:hover {
        transform: translateY(-4px) scale(1.03);
        background: rgba(75, 123, 236, 0.15);
        border-color: rgba(255, 255, 255, 0.25);
        backdrop-filter: blur(24px) saturate(1.4);
        -webkit-backdrop-filter: blur(24px) saturate(1.4);
        box-shadow: 
          0 16px 48px rgba(75, 123, 236, 0.3),
          0 8px 24px rgba(0, 0, 0, 0.15),
          0 0 0 1px rgba(255, 255, 255, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.35),
          inset 0 -1px 0 rgba(0, 0, 0, 0.05);
      }
      .input-price-bar {
        background: rgba(34, 197, 94, 0.25);
        border-color: rgba(34, 197, 94, 0.4);
      }
      .input-price-bar:hover {
        background: rgba(34, 197, 94, 0.35);
        border-color: rgba(34, 197, 94, 0.5);
        box-shadow: 
          0 16px 48px rgba(34, 197, 94, 0.3),
          0 8px 24px rgba(0, 0, 0, 0.15),
          0 0 0 1px rgba(34, 197, 94, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.35),
          inset 0 -1px 0 rgba(0, 0, 0, 0.05);
      }
      
      .output-price-bar {
        background: rgba(239, 68, 68, 0.25);
        border-color: rgba(239, 68, 68, 0.4);
      }
      .output-price-bar:hover {
        background: rgba(239, 68, 68, 0.35);
        border-color: rgba(239, 68, 68, 0.5);
        box-shadow: 
          0 16px 48px rgba(239, 68, 68, 0.3),
          0 8px 24px rgba(0, 0, 0, 0.15),
          0 0 0 1px rgba(239, 68, 68, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.35),
          inset 0 -1px 0 rgba(0, 0, 0, 0.05);
      }
      
      .performance-bar {
        background: rgba(139, 92, 246, 0.25);
        border-color: rgba(139, 92, 246, 0.4);
      }
      .performance-bar:hover {
        background: rgba(139, 92, 246, 0.35);
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow: 
          0 16px 48px rgba(139, 92, 246, 0.3),
          0 8px 24px rgba(0, 0, 0, 0.15),
          0 0 0 1px rgba(139, 92, 246, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.35),
          inset 0 -1px 0 rgba(0, 0, 0, 0.05);
      }
      .bar-value {
        position: absolute;
        top: -2rem;
        width: 100%;
        font-size: 0.8rem;
        font-weight: 900;
        color: #000000;
        text-align: center;
        padding: 0.4rem;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        line-height: 1.2;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 4px;
        margin-bottom: 0.5rem;
        z-index: 20;
        box-sizing: border-box;
      }
      .bar-label {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.92);
        font-weight: 800;
        text-align: center;
        word-wrap: break-word;
        white-space: normal;
        line-height: 1.15;
        max-width: 100%;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
      }
      .bar-label .bar-name { display: block; }
      .bar-label .bar-variant { display: block; font-weight: 600; opacity: 0.85; font-size: 0.8rem; }
      .insights-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.5rem;
        margin-top: 2rem;
        max-width: 1200px;
        margin-left: auto;
        margin-right: auto;
      }
      .insight-card {
        background: var(--glass);
        border-radius: 8px;
        padding: 1.5rem;
        border: 1px solid rgba(161, 166, 180, 0.1);
        transition: transform 0.2s ease;
      }
      .insight-card:hover {
        transform: translateY(-1px);
      }
      .insight-card h4 {
        margin: 0 0 0.5rem 0;
        font-size: 0.9rem;
        color: rgba(248, 248, 248, 0.7);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .insight-card p {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--text-primary);
      }
      
      .no-data {
        text-align: center;
        color: #666;
        padding: 2rem;
        font-style: italic;
      }
      .search-container {
        margin-bottom: 1rem;
      }
      .model-search {
        background: rgba(161, 166, 180, 0.1);
        border: 1px solid rgba(161, 166, 180, 0.3);
        border-radius: 0.5rem;
        color: var(--text-primary);
        padding: 0.5rem 0.75rem;
        width: 100%;
        font-size: 0.875rem;
        backdrop-filter: blur(8px);
        transition: all 0.3s ease;
        outline: none;
      }
      .model-search:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
      }
      .model-search::placeholder {
        color: rgba(161, 166, 180, 0.6);
      }
      .filter-toggle {
        position: fixed;
        left: 1rem;
        bottom: 1rem;
        z-index: 60;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
      }
      
      .filter-toggle:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
        background: #7c4deb;
      }
      
      .filter-toggle:active {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      }
      
      .filter-label {
        font-size: 1.2rem;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
      }
      
      .filter-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        z-index: 40;
      }
      @media (max-width: 800px) {
        .layout {
          flex-direction: column;
          padding: 0;
          max-width: 100%;
        }
        .smart-filter-rail {
          position: fixed;
          top: 0;
          left: 0;
          bottom: 0;
          width: 85%;
          max-width: 320px;
          transform: translateX(-100%);
          z-index: 55;
          overflow-y: auto;
          background: rgba(0, 1, 0, 0.95);
          backdrop-filter: blur(20px);
          border-right: 1px solid rgba(255, 255, 255, 0.1);
          height: 100vh;
          margin-top: 0;
          padding: 1.5rem;
          transition: transform 0.3s ease;
        }
        .smart-filter-rail.open {
          transform: translateX(0);
          box-shadow: 0 4px 32px rgba(0,0,0,0.6);
        }
        .compare-main {
          width: 100%;
          margin-left: 0;
          padding: 1rem;
        }
        .filter-toggle {
          display: block;
        }
        .filter-overlay.active {
          opacity: 1;
          pointer-events: auto;
        }
        .chart-grid {
          grid-template-columns: 1fr;
          gap: 1rem;
        }
        .insights-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 0.75rem;
        }
        .nav-content {
          padding: 1rem;
        }
        .chart-container {
          display: block;
          padding: 0.5rem;
          height: 320px;
          width: 100%;
        }
        .chart-item {
          display: flex;
          flex-direction: column;
          align-items: center;
          flex: 1;
          min-width: 50px;
          max-width: 70px;
        }
      }
      
      @media (max-width: 500px) {
        .insights-grid {
          grid-template-columns: 1fr;
        }
        .layout {
          margin: 1rem auto;
        }
        .filter-toggle {
          bottom: 5rem;
          left: 1rem;
          width: 42px;
          height: 42px;
          font-size: 0.9rem;
        }
        .chart-container {
          padding: 0.5rem;
          height: 300px;
        }
        .chart-item {
          min-width: 45px;
          max-width: 60px;
        }
      }
      .sort-toggle {
        background: var(--glass);
        border: 1px solid rgba(161, 166, 180, 0.3);
        border-radius: 0.5rem;
        color: var(--text-primary);
        padding: 0.5rem 0.75rem;
        width: 100%;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: left;
        backdrop-filter: blur(8px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      .sort-toggle:hover {
        border-color: var(--accent);
        background: rgba(139, 92, 246, 0.15);
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.2);
        transform: translateY(-1px);
      }
      
      .metric-dropdown {
        background: var(--glass);
        border: 1px solid rgba(161, 166, 180, 0.3);
        border-radius: 0.5rem;
        color: var(--text-primary);
        padding: 0.5rem 0.75rem;
        width: 100%;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: left;
        backdrop-filter: blur(8px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='rgba(161, 166, 180, 0.8)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.75rem center;
        background-size: 1rem;
        padding-right: 2.5rem;
      }
      
      .metric-dropdown:hover {
        border-color: var(--accent);
        background-color: rgba(139, 92, 246, 0.15);
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.2);
        transform: translateY(-1px);
      }
      
      .metric-dropdown:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.3);
      }
      
      .metric-dropdown option {
        background-color: #121212;
        color: var(--text-primary);
        padding: 8px;
      }
    </style>
  </head>
  <body>
    <div class="compare-container" style="overflow-x: hidden; width: 100%; max-width: 100vw;">
      <Header currentPage="compare" />

      <button class="filter-toggle" id="filter-toggle" aria-expanded="false" aria-label="Toggle filters">
        <span class="filter-label">&lt;=&gt;</span>
      </button>
      <div class="filter-overlay" id="filter-overlay"></div>

      <div class="layout">
        <aside class="smart-filter-rail" id="smart-filter-rail">
          <div class="filter-section">
            <h3>Performance Metric</h3>
            <select id="metric-selector" class="metric-dropdown">
              {Object.entries(availableBenchmarks).map(([value, label]) => (
                <option value={value} selected={value === 'mmlu_pro'}>{label}</option>
              ))}
            </select>
          </div>
          <div class="filter-section">
            <h3>Sort Order</h3>
            <button id="sort-toggle" class="sort-toggle" data-order="desc">
              <span class="sort-text">High to Low</span>
            </button>
          </div>
          <div class="filter-section">
            <h3>Model Selection</h3>
            <div class="search-container">
              <input type="text" id="model-search" placeholder="Search models..." class="model-search">
            </div>
            <div class="selected-count"></div>
            <div class="model-list"></div>
          </div>
        </aside>

        <main class="compare-main">
          <section class="charts-section">
            <div class="chart-grid">
              <div class="chart-section">
                <div class="chart-header">
                  <h3>Price Comparison</h3>
                </div>
                <div class="chart-container" id="price-chart"><canvas id="price-canvas"></canvas></div>
              </div>

              <div class="chart-section">
                <div class="chart-header">
                  <h3>Performance Comparison</h3>
                </div>
                <div class="chart-container" id="performance-chart"><canvas id="perf-canvas"></canvas></div>
              </div>
            </div>
          </section>

          <section class="insights-section">
            <div class="insights-grid">
              <div class="insight-card">
                <h4>Cheapest Tokens</h4>
                <p>{cheapestTokensModel ? cheapestTokensModel.name : '—'}</p>
              </div>
              <div class="insight-card">
                <h4>Cheapest Input</h4>
                <p>{inputPriceWinner ? inputPriceWinner.name : '—'}</p>
              </div>
              <div class="insight-card">
                <h4>Cheapest Output</h4>
                <p>{outputPriceWinner ? outputPriceWinner.name : '—'}</p>
              </div>
              <div class="insight-card">
                <h4>Highest TPS</h4>
                <p>{tpsWinner ? tpsWinner.name : '—'}</p>
              </div>
              <div class="insight-card">
                <h4>Fastest TTFT</h4>
                <p>{ttftWinner ? ttftWinner.name : '—'}</p>
              </div>
              <div class="insight-card">
                <h4 id="performance-metric-title">Top MMLU Pro</h4>
                <p>{performanceWinner ? performanceWinner.name : '—'}</p>
              </div>
            </div>
          </section>
        </main>
      </div>
    </div>

    <!-- Chart.js (CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>

    <script define:vars={{ validModels }}>
      // Security: HTML sanitization function to prevent XSS attacks
      function sanitizeHTML(str) {
        const div = document.createElement('div');
        div.textContent = str || '';
        return div.innerHTML;
      }

      // Dynamically ensure Chart.js is available (in case CDN is blocked)
      let __chartLibLoading = null;
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = src;
          s.async = true;
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }
      async function ensureChartLibs() {
        if (window.Chart && (window.ChartDataLabels || window['ChartDataLabels'])) return true;
        if (!__chartLibLoading) {
          __chartLibLoading = (async () => {
            if (!window.Chart) {
              await loadScript('https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js');
            }
            if (!(window.ChartDataLabels || window['ChartDataLabels'])) {
              await loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js');
            }
            return true;
          })();
        }
        return __chartLibLoading;
      }

      async function initCompare() {
        // Initialize sidebar state based on screen size
        const initializeLayout = () => {
          const isMobile = window.innerWidth <= 800;
          const rail = document.getElementById('smart-filter-rail');
          const main = document.querySelector('.compare-main');
          const toggle = document.getElementById('filter-toggle');
          const label = toggle?.querySelector('.filter-label');
          
          if (isMobile) {
            rail?.classList.remove('closed');
            rail?.classList.remove('open');
            if (label) label.innerHTML = '&lt;=&gt;';
          } else {
            // Default to showing sidebar on desktop
            rail?.classList.remove('closed');
            if (main) {
              main.style.marginLeft = '280px';
              main.style.width = 'calc(100% - 280px)';
            }
            if (label) label.innerHTML = '&times;';
          }
        };
        
        // Call initially and on resize
        initializeLayout();
        window.addEventListener('resize', initializeLayout);

        const toggle = document.getElementById('filter-toggle');
        const rail = document.getElementById('smart-filter-rail');
        const overlay = document.getElementById('filter-overlay');

        function closeFilters() {
          const isMobile = window.innerWidth <= 800;
          
          if (isMobile) {
            rail.classList.remove('open');
            overlay.classList.remove('active');
            toggle.setAttribute('aria-expanded', 'false');
            const label = toggle.querySelector('.filter-label');
            if (label) label.innerHTML = '&lt;=&gt;';
          } else {
            rail.classList.add('closed');
            toggle.setAttribute('aria-expanded', 'false');
            const label = toggle.querySelector('.filter-label');
            if (label) label.innerHTML = '&lt;=&gt;';
            
            // Adjust main content area
            const main = document.querySelector('.compare-main');
            if (main) {
              main.style.marginLeft = '0';
              main.style.width = '100%';
            }
          }
        }

        toggle?.addEventListener('click', () => {
          // For mobile, we use 'open' class to show the sidebar
          // For desktop, we use 'closed' class to hide the sidebar
          const isMobile = window.innerWidth <= 800;
          
          if (isMobile) {
            const isOpen = rail.classList.toggle('open');
            overlay.classList.toggle('active', isOpen);
            toggle.setAttribute('aria-expanded', isOpen.toString());
            const label = toggle.querySelector('.filter-label');
            if (label) label.innerHTML = isOpen ? '&times;' : '&lt;=&gt;';
          } else {
            const isClosed = rail.classList.toggle('closed');
            toggle.setAttribute('aria-expanded', (!isClosed).toString());
            const label = toggle.querySelector('.filter-label');
            if (label) label.innerHTML = isClosed ? '&lt;=&gt;' : '&times;';
            
            // Also adjust the main content area when sidebar is toggled
            const main = document.querySelector('.compare-main');
            if (main) {
              main.style.marginLeft = isClosed ? '0' : '280px';
              main.style.width = isClosed ? '100%' : 'calc(100% - 280px)';
            }
          }
        });

        overlay?.addEventListener('click', closeFilters);

        // Dynamic model selection and charts
        const models = validModels;
        let filteredModels = [...models]; // For search filtering
        const selected = new Set(models.slice(0, 3).map((m) => m.id));
        const list = document.querySelector('.model-list');
        const countEl = document.querySelector('.selected-count');
        const priceChart = document.getElementById('price-chart');
        const perfChart = document.getElementById('performance-chart');
        const priceCanvas = document.getElementById('price-canvas');
        const perfCanvas = document.getElementById('perf-canvas');
        let priceChartInstance = null;
        let perfChartInstance = null;
        const metricSelector = document.getElementById('metric-selector');
        const performanceMetricTitle = document.getElementById('performance-metric-title');
        
        // Benchmark display names mapping (client-side)
        const benchmarkNames = {
          'mmlu_pro': 'MMLU Pro',
          'gpqa': 'GPQA',
          'hle': 'HumanEval',
          'aa_math_index': 'Math Index',
          'aa_coding_index': 'Coding Index',
          'aa_intelligence_index': 'Intelligence Index',
          'livecodebench': 'LiveCodeBench',
          'scicode': 'SciCode',
          'math_500': 'Math 500',
          'aime': 'AIME',
          'elo': 'ELO Rating'
        };
        const sortToggle = document.getElementById('sort-toggle');
        const searchInput = document.getElementById('model-search');

        function formatScore(value) {
          if (value === null || value === undefined) return '—';
          const num = Number(value);
          if (!isFinite(num) || num <= 0) return '—';
          const pct = num <= 1 ? num * 100 : num;
          return `${pct.toFixed(1)}%`;
        }

        function applyFiltersAndSort() {
          const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

          // Filter by search term only
          filteredModels = models.filter(model => 
            model.name.toLowerCase().includes(searchTerm)
          );
        }

        function renderModelList() {
          if (!list) return;
          applyFiltersAndSort();
          
          list.innerHTML = filteredModels.map((m) => `
            <div class="model-item">
              <input type="checkbox" id="model-${m.id}" data-id="${m.id}" ${selected.has(m.id) ? 'checked' : ''} />
              <label for="model-${m.id}">${sanitizeHTML(m.name)}</label>
            </div>
          `).join('');
        }

        function updateCount() {
          if (countEl) countEl.textContent = `${selected.size} of ${filteredModels.length} models selected`;
        }

        function getSelected() {
          return models.filter((m) => selected.has(m.id));
        }

        function updateInsights(models) {
          if (models.length === 0) return;
          
          // Find cheapest tokens model (lowest blended price)
          let cheapestTokensModel = null;
          let lowestBlendedPrice = Infinity;
          
          // Find cheapest input, output, top performer, TPS winner, and TTFT winner for current metric
          let cheapestInputModel = models[0];
          let cheapestOutputModel = models[0];
          let topPerformerModel = models[0];
          let tpsWinnerModel = null;
          let ttftWinnerModel = null;
          let highestTPS = 0;
          let fastestTTFT = Infinity;
          
          const currentMetric = metricSelector.value;
          
          models.forEach(model => {
            // Find model with lowest blended price
            const blendedPrice = model.price_1m_blended_3_to_1;
            const priceNum = parseFloat(blendedPrice);
            
            console.log(`Checking ${model.name}: Blended Price=${blendedPrice}, parsed=${priceNum}, current lowest=${lowestBlendedPrice}`);
            
            if (blendedPrice !== null && blendedPrice !== undefined && !isNaN(priceNum) && priceNum > 0 && priceNum < lowestBlendedPrice) {
              console.log(`New cheapest tokens: ${model.name} with $${priceNum}`);
              lowestBlendedPrice = priceNum;
              cheapestTokensModel = model;
            }
            
            if ((Number(model.price_1m_input_tokens) || Infinity) < (Number(cheapestInputModel.price_1m_input_tokens) || Infinity)) {
              cheapestInputModel = model;
            }
            
            if ((Number(model.price_1m_output_tokens) || Infinity) < (Number(cheapestOutputModel.price_1m_output_tokens) || Infinity)) {
              cheapestOutputModel = model;
            }
            
            if ((Number(model[currentMetric]) || 0) > (Number(topPerformerModel[currentMetric]) || 0)) {
              topPerformerModel = model;
            }
            
            // Find TPS winner (highest tokens per second)
            const modelTPS = model.median_output_tokens_per_second;
            const winnerTpsNum = parseFloat(modelTPS);
            if (modelTPS !== null && modelTPS !== undefined && !isNaN(winnerTpsNum) && winnerTpsNum > 0 && winnerTpsNum > highestTPS) {
              highestTPS = winnerTpsNum;
              tpsWinnerModel = model;
            }
            
            // Find TTFT winner (fastest time to first token - lower is better)
            const modelTTFT = model.median_time_to_first_answer_token;
            const ttftNum = parseFloat(modelTTFT);
            if (modelTTFT !== null && modelTTFT !== undefined && !isNaN(ttftNum) && ttftNum > 0 && ttftNum < fastestTTFT) {
              fastestTTFT = ttftNum;
              ttftWinnerModel = model;
            }
          });
          
          // Update the insight cards
          const insightCards = document.querySelectorAll('.insight-card p');
          if (insightCards.length >= 6) {
            insightCards[0].textContent = cheapestTokensModel ? cheapestTokensModel.name : '—';
            insightCards[1].textContent = cheapestInputModel.name;
            insightCards[2].textContent = cheapestOutputModel.name;
            insightCards[3].textContent = tpsWinnerModel ? tpsWinnerModel.name : '—';
            insightCards[4].textContent = ttftWinnerModel ? ttftWinnerModel.name : '—';
            insightCards[5].textContent = topPerformerModel.name;
          }
        }
        
        function renderCharts() {
          let chosen = getSelected();
          console.log('Rendering charts for models:', chosen.length);

          // Ensure chart containers exist (metric selector is optional)
          if (!priceChart || !perfChart) {
            console.error('Chart elements not found');
            console.log('Price chart element:', priceChart);
            console.log('Performance chart element:', perfChart);
            return;
          }
          
          // Update insights section
          updateInsights(chosen);

          // Clear any existing "no data" messages but preserve the container structure
          const existingNoData = priceChart.querySelector('.no-data');
          if (existingNoData) existingNoData.remove();
          
          if (chosen.length === 0) {
            // Add "no data" message without clearing the container
            if (!priceChart.querySelector('.no-data')) {
              const noDataEl = document.createElement('div');
              noDataEl.className = 'no-data';
              noDataEl.style.cssText = 'text-align: center; color: #666; padding: 2rem;';
              noDataEl.textContent = 'Select models to compare';
              priceChart.appendChild(noDataEl);
            }
            
            if (!perfChart.querySelector('.no-data')) {
              const noDataEl = document.createElement('div');
              noDataEl.className = 'no-data';
              noDataEl.style.cssText = 'text-align: center; color: #666; padding: 2rem;';
              noDataEl.textContent = 'Select models to compare';
              perfChart.appendChild(noDataEl);
            }
            return;
          }

          // Get sort order and metric
          const sortOrder = sortToggle ? sortToggle.getAttribute('data-order') : 'desc';
          const metric = metricSelector ? metricSelector.value : 'mmlu_pro';
          
          // Update performance chart title with benchmark name
          const perfChartHeader = document.querySelector('#performance-chart').parentElement.querySelector('.chart-header h3');
          if (perfChartHeader) {
            const metricDisplayNames = {
              'mmlu_pro': 'MMLU PRO',
              'gpqa': 'GPQA', 
              'math': 'MATH',
              'humaneval': 'HumanEval',
              'drop': 'DROP'
            };
            const benchmarkName = metricDisplayNames[metric] || metric.toUpperCase().replace('_', ' ');
            perfChartHeader.textContent = `${benchmarkName} Performance Comparison`;
            console.log('Updated chart title to:', perfChartHeader.textContent);
          } else {
            console.log('Could not find performance chart header');
          }

          // Do not clear containers; destroy existing chart instances instead
          if (priceChartInstance) { priceChartInstance.destroy(); priceChartInstance = null; }
          if (perfChartInstance) { perfChartInstance.destroy(); perfChartInstance = null; }

          // Sort chosen models by price for price chart
          const chosenByPrice = [...chosen].sort((a, b) => {
            const totalA = (Number(a.price_1m_input_tokens) || 0) + (Number(a.price_1m_output_tokens) || 0);
            const totalB = (Number(b.price_1m_input_tokens) || 0) + (Number(b.price_1m_output_tokens) || 0);
            return sortOrder === 'desc' ? totalB - totalA : totalA - totalB;
          });
          
          const totals = chosenByPrice.map((m) => (Number(m.price_1m_input_tokens) || 0) + (Number(m.price_1m_output_tokens) || 0));
          const maxTotal = Math.max(...totals, 1);
          
          // Calculate dynamic width based on number of models
          const numModels = chosenByPrice.length;
          const dynamicWidth = Math.max(60, Math.min(120, 800 / numModels));
          const dynamicGap = numModels > 6 ? '0.5rem' : '1rem';
          
          // Update container gap for this render
          if (priceChart.parentElement) {
            priceChart.parentElement.style.gap = dynamicGap;
          }
          
          // Ensure canvases have concrete pixel sizes
          if (priceCanvas) {
            const pr = priceChart.getBoundingClientRect();
            priceCanvas.width = Math.max(300, priceChart.clientWidth || pr.width || 600);
            priceCanvas.height = Math.max(200, priceChart.clientHeight || pr.height || 360);
          }
          if (perfCanvas) {
            const rr = perfChart.getBoundingClientRect();
            perfCanvas.width = Math.max(300, perfChart.clientWidth || rr.width || 600);
            perfCanvas.height = Math.max(200, perfChart.clientHeight || rr.height || 360);
          }

          // Build price chart using Chart.js
          const labelParts = (name) => {
            const m = name.match(/^(.*?)(\s*\(([^)]*)\))?$/);
            const base = m ? m[1] : name;
            const variant = m && m[3] ? m[3] : '';
            return variant ? [base, `(${variant})`] : [base];
          };
          const priceLabels = chosenByPrice.map(m => labelParts(m.name));
          const inputData = chosenByPrice.map(m => Number(m.price_1m_input_tokens) || 0);
          const outputData = chosenByPrice.map(m => Number(m.price_1m_output_tokens) || 0);
          if (priceCanvas && window.Chart) {
            window.Chart.register(window.ChartDataLabels || window['ChartDataLabels']);
            priceChartInstance = new window.Chart(priceCanvas.getContext('2d'), {
              type: 'bar',
              data: {
                labels: priceLabels,
                datasets: [
                  {
                    label: 'Input',
                    data: inputData,
                    backgroundColor: 'rgba(34,197,94,0.35)',
                    borderColor: 'rgba(34,197,94,0.6)',
                    borderWidth: 1,
                    borderRadius: 10,
                  },
                  {
                    label: 'Output',
                    data: outputData,
                    backgroundColor: 'rgba(239,68,68,0.35)',
                    borderColor: 'rgba(239,68,68,0.6)',
                    borderWidth: 1,
                    borderRadius: 10,
                  },
                ],
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                  legend: { position: 'bottom', labels: { color: '#eae9f0' } },
                  tooltip: { callbacks: { label: (ctx) => `$${(ctx.parsed.y ?? 0).toFixed(3)} per 1M` } },
                  datalabels: {
                    anchor: 'end', align: 'end', color: '#111', backgroundColor: 'rgba(255,255,255,0.9)',
                    borderRadius: 4, padding: 4, font: { weight: '900' },
                    formatter: (v) => `$${(v >= 10 ? v.toFixed(1) : v.toFixed(2))}`,
                  },
                },
                scales: {
                  x: { ticks: { color: '#eae9f0', maxRotation: 45, minRotation: 45 }, grid: { display: false } },
                  y: { beginAtZero: true, ticks: { color: '#eae9f0', callback: (v) => `$${Number(v).toFixed(0)}` },
                       grid: { color: 'rgba(255,255,255,0.08)', drawBorder: false } },
                },
              },
              plugins: [window.ChartDataLabels || window['ChartDataLabels']],
            });
          }

          // Sort chosen models by selected metric for performance chart
          const chosenByMetric = [...chosen].sort((a, b) => {
            const scoreA = Number(a[metric]) || 0;
            const scoreB = Number(b[metric]) || 0;
            return sortOrder === 'desc' ? scoreB - scoreA : scoreA - scoreB;
          });
          
          // Build performance chart using Chart.js
          const perfLabels = chosenByMetric.map(m => labelParts(m.name));
          const scores = chosenByMetric.map(m => Number(m[metric]) || 0);
          if (perfCanvas && window.Chart) {
            window.Chart.register(window.ChartDataLabels || window['ChartDataLabels']);
            const maxScore = scores.length ? Math.max(...scores) : 0;
            perfChartInstance = new window.Chart(perfCanvas.getContext('2d'), {
              type: 'bar',
              data: {
                labels: perfLabels,
                datasets: [
                  {
                    label: 'Score',
                    data: scores,
                    backgroundColor: 'rgba(139,92,246,0.35)',
                    borderColor: 'rgba(139,92,246,0.6)',
                    borderWidth: 1,
                    borderRadius: 10,
                  },
                ],
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: { display: false },
                  tooltip: { callbacks: { label: (ctx) => {
                    const y = ctx.parsed.y ?? 0;
                    const t = Math.trunc(y * 1000) / 1000; // truncate, no rounding
                    return `${t.toFixed(3)}%`;
                  } } },
                  datalabels: {
                    anchor: 'end', align: 'end', color: '#111', backgroundColor: 'rgba(255,255,255,0.9)',
                    borderRadius: 4, padding: 4, font: { weight: '900' }, clip: false,
                    formatter: (v) => {
                      const t = Math.trunc(Number(v) * 1000) / 1000; // truncate
                      return `${t.toFixed(3)}%`;
                    },
                  },
                },
                scales: {
                  x: { ticks: { color: '#eae9f0', maxRotation: 45, minRotation: 45 }, grid: { display: false } },
                  y: { beginAtZero: true, suggestedMax: maxScore * 1.05,
                       ticks: { color: '#eae9f0', callback: (v) => `${Number(v).toFixed(3)}%` },
                       grid: { color: 'rgba(255,255,255,0.08)', drawBorder: false } },
                },
                layout: { padding: { top: 28 } },
              },
              plugins: [window.ChartDataLabels || window['ChartDataLabels']],
            });
          }

          console.log('Charts rendered successfully with', chosen.length, 'models');
        }

        list?.addEventListener('change', (e) => {
          const target = e.target;
          if (target instanceof HTMLInputElement && target.dataset.id) {
            target.checked ? selected.add(target.dataset.id) : selected.delete(target.dataset.id);
            updateCount();
            renderCharts();
          }
        });

        // Metric selector change handler (consolidated)
        metricSelector?.addEventListener('change', async () => {
          // Update the performance metric title
          const selectedMetric = metricSelector.value;
          const displayName = benchmarkNames[selectedMetric] || selectedMetric;
          if (performanceMetricTitle) {
            performanceMetricTitle.textContent = `Top ${displayName}`;
          }
          
          // Render charts and refresh data
          renderCharts();
          await refreshDataAndCharts();
        });

        // Add event listeners for new features
        searchInput?.addEventListener('input', () => {
          renderModelList();
          updateCount();
        });

        // Sort toggle functionality
        sortToggle?.addEventListener('click', () => {
          if (sortToggle) {
            const currentOrder = sortToggle.getAttribute('data-order');
            const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
            sortToggle.setAttribute('data-order', newOrder);
            const textEl = sortToggle.querySelector('.sort-text');
            if (textEl) {
              textEl.textContent = newOrder === 'desc' ? 'High to Low' : 'Low to High';
            }
            renderCharts(); // Only re-render charts, not model list
          }
        });

        renderModelList();
        updateCount();
        try {
          await ensureChartLibs();
        } catch (e) {
          console.error('Failed to load chart libraries', e);
        }
        renderCharts();
      }

      // Auto-fit functionality for charts
      function initAutoFit() {
        const priceChart = document.getElementById('price-chart');
        const perfChart = document.getElementById('performance-chart');
        
        function fitModelsToChart(chart) {
          if (!chart) return;
          
          const chartItems = chart.querySelectorAll('.chart-item');
          if (!chartItems.length) return;
          
          // Calculate the minimum width needed to fit all items
          const totalItems = chartItems.length;
          const containerWidth = chart.clientWidth;
          // Account for gap between items (0.75rem = ~12px) and ensure all fit
          const totalGapWidth = (totalItems - 1) * 12;
          const availableWidth = containerWidth - totalGapWidth - 10; // 10px buffer
          const minItemWidth = Math.max(20, Math.floor(availableWidth / totalItems));
          
          // Apply the calculated width to all items
          chartItems.forEach(item => {
            item.style.minWidth = minItemWidth + 'px';
            item.style.maxWidth = minItemWidth + 'px';
            item.style.flex = '0 0 auto';
            
            // Improve overlapping names: allow up to 2 lines with ellipsis
            const label = item.querySelector('.bar-label');
            if (label) {
              label.style.maxWidth = minItemWidth + 'px';
              label.style.overflow = 'hidden';
              label.style.display = '-webkit-box';
              label.style.webkitBoxOrient = 'vertical';
              label.style.webkitLineClamp = '2';
              label.setAttribute('title', label.textContent || '');
            }
          });
          
          // Center items in the container
          chart.style.justifyContent = 'center';
        }
        
        // Apply auto-fit when charts are rendered
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
              if (mutation.target === priceChart || mutation.target === perfChart) {
                fitModelsToChart(mutation.target);
              }
            }
          });
        });
        
        // Observe both charts for changes
        if (priceChart) {
          observer.observe(priceChart, { childList: true });
          // Initial fit if chart already has content
          fitModelsToChart(priceChart);
        }
        
        if (perfChart) {
          observer.observe(perfChart, { childList: true });
          // Initial fit if chart already has content
          fitModelsToChart(perfChart);
        }
        
        // Re-fit on window resize
        window.addEventListener('resize', () => {
          fitModelsToChart(priceChart);
          fitModelsToChart(perfChart);
        });

      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          initCompare();
          initAutoFit();
        });
      } else {
        initCompare();
        initAutoFit();
      }
    </script>
  </body>
</html>
