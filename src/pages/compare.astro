---
import {
  getModels,
  getEpochModels,
  getEpochBenchmarks,
  getEpochBenchmarkRuns,
} from "../lib/supabase";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import ScrollToTop from "../components/ScrollToTop.astro";
import Layout from "../components/Layout.astro";

const models = await getModels();

// Fetch epoch.ai benchmark data
const epochModels = await getEpochModels();
const epochBenchmarks = await getEpochBenchmarks();
const epochRuns = await getEpochBenchmarkRuns();

const normalizeModelKey = (value: string | null | undefined): string => {
  if (!value) return "";
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .trim();
};

const epochAliasesByModelVersion: Record<string, string[]> = {};
epochModels.forEach((model) => {
  if (!model.model_version) return;
  const aliases = new Set<string>();
  [model.model_version, model.model_name, model.display_name].forEach(
    (candidate) => {
      const normalized = normalizeModelKey(candidate);
      if (!normalized) return;
      aliases.add(normalized);
      aliases.add(normalized.replace(/\s+/g, ""));
    },
  );
  if (aliases.size > 0) {
    epochAliasesByModelVersion[model.model_version] = Array.from(aliases);
  }
});

// Keep only epoch benchmarks that have at least one scored run
const epochBenchmarksWithData = epochBenchmarks.filter((b) =>
  epochRuns.some((run) => run.benchmark_slug === b.slug && run.score !== null),
);

// Create a map of epoch benchmark scores keyed by normalized aliases.
const epochScoresByModel: Record<string, Record<string, number>> = {};
const registerEpochScore = (
  aliasKey: string,
  benchmarkSlug: string,
  score: number,
) => {
  if (!aliasKey) return;
  if (!epochScoresByModel[aliasKey]) {
    epochScoresByModel[aliasKey] = {};
  }
  epochScoresByModel[aliasKey][benchmarkSlug] = score;
};

epochRuns.forEach((run) => {
  if (!run.model_version || run.score === null || !run.benchmark_slug) return;
  const normalizedVersion = normalizeModelKey(run.model_version);
  const aliases = new Set<string>([
    normalizedVersion,
    normalizedVersion.replace(/\s+/g, ""),
    ...(epochAliasesByModelVersion[run.model_version] ?? []),
  ]);

  aliases.forEach((alias) => {
    registerEpochScore(alias, run.benchmark_slug!, run.score!);
  });
});

const validModels = models.filter((model: any) => {
  const inputPrice = Number(model.price_1m_input_tokens);
  const outputPrice = Number(model.price_1m_output_tokens);
  return inputPrice > 0 && outputPrice > 0;
});

const INITIAL_CLIENT_MODELS = Math.min(40, validModels.length);
const initialClientModels = validModels.slice(0, INITIAL_CLIENT_MODELS);
const initialClientEpochScores = epochScoresByModel;

const selectedModels = validModels.slice(0, 3);

const getWinner = (items: any[], key: string, isLowerBetter = false) => {
  const usable = items.filter((m) => Number(m[key]) > 0);
  if (usable.length === 0) return null;
  return usable.sort((a, b) => {
    const valA = Number(a[key]);
    const valB = Number(b[key]);
    return isLowerBetter ? valA - valB : valB - valA;
  })[0];
};

const inputPriceWinner = getWinner(
  selectedModels,
  "price_1m_input_tokens",
  true,
);
const outputPriceWinner = getWinner(
  selectedModels,
  "price_1m_output_tokens",
  true,
);
const performanceWinner = getWinner(selectedModels, "mmlu_pro");
const tpsWinner = getWinner(selectedModels, "median_output_tokens_per_second");
const ttftWinner = getWinner(
  selectedModels,
  "median_time_to_first_answer_token",
  true,
);

const getCheapestTokensModel = () => {
  if (selectedModels.length === 0) return null;
  const modelsWithBlendedPrice = selectedModels.filter((model) => {
    const blendedPrice = model.price_1m_blended_3_to_1;
    const priceNum = Number(blendedPrice);
    return (
      blendedPrice !== null &&
      blendedPrice !== undefined &&
      !isNaN(priceNum) &&
      priceNum > 0
    );
  });
  if (modelsWithBlendedPrice.length === 0) return null;

  const sorted = modelsWithBlendedPrice.sort((a, b) => {
    const priceA = Number(a.price_1m_blended_3_to_1);
    const priceB = Number(b.price_1m_blended_3_to_1);
    return priceA - priceB; // Lower price is better
  });

  return sorted[0];
};

const cheapestTokensModel = getCheapestTokensModel();

// SEO Configuration is now handled by Layout.astro

// Dynamic benchmark mapping - Combined AA and Epoch benchmarks
const availableBenchmarks: Record<string, string> = {
  // AA Benchmarks
  mmlu_pro: "MMLU Pro",
  gpqa: "GPQA",
  hle: "HumanEval",
  aa_math_index: "Math Index",
  aa_coding_index: "Coding Index",
  aa_intelligence_index: "Intelligence Index",
  livecodebench: "LiveCodeBench",
  scicode: "SciCode",
  math_500: "Math 500",
  aime: "AIME",
  elo: "ELO Rating",
};

// Add Epoch.ai benchmarks to the dropdown (only those with data)
epochBenchmarksWithData.forEach((b) => {
  availableBenchmarks[`epoch_${b.slug}`] = `${b.name} (Epoch)`;
});

// Top epoch benchmark performers for insights
const topGpqaDiamond =
  epochRuns
    .filter((r) => r.benchmark_slug === "gpqa_diamond" && r.score !== null)
    .sort((a, b) => (b.score ?? 0) - (a.score ?? 0))[0] ?? null;

const topFrontierMath =
  epochRuns
    .filter((r) => r.benchmark_slug === "frontiermath" && r.score !== null)
    .sort((a, b) => (b.score ?? 0) - (a.score ?? 0))[0] ?? null;
---

<Layout
  title="Compare AI Models - Pricing & Performance | AI Stats"
  description="Compare AI model pricing, benchmarks, and specifications side-by-side. Interactive charts for GPT-4, Claude, Gemini, Llama and more. Filter by performance metrics including MMLU Pro, GPQA, and coding benchmarks."
>
  <style>
    .bar-stack-duo {
      height: 170px;
      width: 100%;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 2px;
    }
    .bar-stack {
      height: 200px;
      width: 100%;
      display: flex;
      align-items: flex-end;
      justify-content: center;
    }

    .layout {
      display: flex;
      gap: 0;
      max-width: 100%;
      margin: 0;
      padding: 0;
      align-items: flex-start;
      box-sizing: border-box;
      width: 100%;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden; /* Prevent horizontal overflow */
    }
    .smart-filter-rail {
      width: 280px;
      min-width: 280px;
      flex-shrink: 0;
      background: var(--surface);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-right: 2px solid var(--border-color);
      padding: 5rem 1.25rem 2rem;
      height: 100vh;
      overflow-y: auto;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 40;
      transform: translateX(0);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      scrollbar-width: thin;
      scrollbar-color: rgba(156, 207, 216, 0.3) transparent;
    }

    .smart-filter-rail::-webkit-scrollbar {
      width: 6px;
    }

    .smart-filter-rail::-webkit-scrollbar-track {
      background: transparent;
    }

    .smart-filter-rail::-webkit-scrollbar-thumb {
      background: rgba(156, 207, 216, 0.3);
      border-radius: 3px;
    }

    html.light .smart-filter-rail {
      background: var(--surface);
      border-right: 2px solid var(--border-color);
    }

    .smart-filter-rail.closed {
      transform: translateX(-100%);
    }
    @media (max-width: 800px) {
      .layout {
        flex-direction: column;
        padding: 0;
      }
      .smart-filter-rail {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: 85%;
        max-width: 320px;
        transform: translateX(-100%);
        z-index: 55;
        overflow-y: auto;
        background: var(--base);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border-right: 2px solid var(--border-color);
        box-shadow: 4px 0px 0px var(--shadow-color);
        height: 100vh;
        padding: 1rem 1.5rem;
        padding-top: 5rem; /* Adjusted padding for mobile */
        transition: transform 0.3s ease;
      }
      .smart-filter-rail.open {
        transform: translateX(0);
      }
      .compare-main {
        margin: 0;
        padding: 1rem;
        max-width: 100%;
        width: 100%;
      }
      .chart-grid {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 1.5rem;
        width: 100%;
      }
      .chart-section {
        width: 100%;
        max-width: 500px;
        margin: 0 auto 1.5rem auto;
        padding: 1rem;
      }
      .chart-container {
        /* For Chart.js canvas, use block layout */
        display: block;
        padding: 2rem 0.5rem 1rem 0.5rem;
        height: 420px;
        width: 100%;
        overflow: visible;
        position: relative;
        box-sizing: border-box;
        scrollbar-color: var(--accent) rgba(0, 0, 0, 0.2);
      }
      /* Make canvases fill container */
      #price-canvas,
      #perf-canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
      }

      .chart-container::-webkit-scrollbar {
        height: 6px;
      }

      .chart-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
      }

      .chart-container::-webkit-scrollbar-thumb {
        background-color: var(--accent);
        border-radius: 3px;
      }
      .chart-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        min-width: 50px;
        max-width: 70px;
      }
      .filter-toggle {
        display: block;
      }
    }
    .filter-section {
      margin-bottom: 1.75rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid rgba(156, 207, 216, 0.08);
    }

    .filter-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    .filter-section h3 {
      margin-bottom: 0.75rem;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #6e6a86;
    }

    html.light .filter-section h3 {
      color: #797593;
    }

    .model-list {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      max-height: 320px;
      overflow-y: auto;
      padding-right: 0.5rem;
      margin-right: -0.5rem;
      scrollbar-width: thin;
      scrollbar-color: rgba(156, 207, 216, 0.3) transparent;
    }

    .model-list::-webkit-scrollbar {
      width: 4px;
    }

    .model-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .model-list::-webkit-scrollbar-thumb {
      background: rgba(156, 207, 216, 0.3);
      border-radius: 2px;
    }

    .model-item {
      display: flex;
      align-items: center;
      gap: 0.625rem;
      padding: 0.5rem 0.625rem;
      border-radius: 8px;
      transition: background 0.2s ease;
      cursor: pointer;
    }

    .model-item:hover {
      background: rgba(156, 207, 216, 0.08);
    }

    .model-item input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(156, 207, 216, 0.4);
      border-radius: 4px;
      background: transparent;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.2s ease;
      position: relative;
    }

    .model-item input[type="checkbox"]:checked {
      background: linear-gradient(135deg, #9ccfd8, #7fb5c0);
      border-color: #9ccfd8;
    }

    .model-item input[type="checkbox"]:checked::after {
      content: "";
      position: absolute;
      left: 4px;
      top: 1px;
      width: 4px;
      height: 8px;
      border: solid #191724;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    .model-item label {
      font-size: 0.8rem;
      color: #e0def4;
      cursor: pointer;
      line-height: 1.3;
    }

    html.light .model-item label {
      color: #575279;
    }

    .selected-count {
      font-size: 0.75rem;
      color: #9ccfd8;
      font-weight: 500;
      margin-bottom: 0.75rem;
      padding: 0.5rem 0.75rem;
      background: rgba(156, 207, 216, 0.1);
      border-radius: 6px;
      border: 1px solid rgba(156, 207, 216, 0.15);
    }
    .compare-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2rem;
      min-width: 0;
      width: calc(100% - 280px);
      margin-left: 280px;
      padding: 2rem;
      box-sizing: border-box;
      max-width: 100%;
      overflow-x: hidden; /* Prevent horizontal overflow */
    }
    .chart-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 2rem;
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }
    .chart-card {
      background: var(--glass);
      border-radius: 8px;
      padding: 1rem;
    }
    .chart-section {
      background: var(--surface);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 4px;
      padding: 2rem;
      border: 2px solid var(--border-color);
      box-shadow: 4px 4px 0px var(--shadow-color);
      width: 100%;
      transition:
        transform 0.1s ease,
        box-shadow 0.1s ease;
      position: relative;
      z-index: 1;
      overflow: visible;
    }
    html.light .chart-section {
      background: var(--surface);
      border: 2px solid var(--border-color);
      box-shadow: 4px 4px 0px var(--shadow-color);
    }
    @media (prefers-reduced-motion: no-preference) {
      .chart-section:hover {
        transform: translate(-2px, -2px);
        box-shadow: 6px 6px 0px var(--shadow-color);
        border-color: var(--border-color);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .chart-section:hover {
        border-color: var(--border-color);
      }
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .chart-header h3 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
      color: #f8f8f8;
    }
    html.light .chart-header h3 {
      color: #575279;
    }

    .zoom-button {
      background: var(--surface);
      color: var(--text);
      border: 2px solid var(--border-color);
      border-radius: 4px;
      padding: 0.25rem 0.75rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.1s ease;
      box-shadow: 2px 2px 0 var(--shadow-color);
    }

    .zoom-button:hover {
      background: var(--highlight-low);
      border-color: var(--border-color);
      transform: translate(-1px, -1px);
      box-shadow: 3px 3px 0 var(--shadow-color);
    }

    .zoom-button.active {
      background: var(--highlight-med);
      border-color: var(--border-color);
      transform: translate(2px, 2px);
      box-shadow: 0px 0px 0 var(--shadow-color);
    }
    .chart-container {
      display: block;
      width: 100%;
      height: 360px;
      min-height: 300px;
      position: relative;
      box-sizing: border-box;
      overflow: visible;
      padding-top: 2rem;
      background: var(--highlight-low);
      border-radius: 4px;
      padding: 1rem;
      border: 2px solid var(--border-color);
      position: relative;
      margin: 0 auto;
      scrollbar-width: thin;
    }
    .chart-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 72px;
      position: relative;
      flex: none;
    }
    .chart-bar {
      width: 100%;
      min-width: 40px;
      border-radius: 12px;
      transition:
        background 0.2s ease,
        border-color 0.2s ease,
        box-shadow 0.2s ease;
      position: relative;
      margin-top: auto;
      background: rgba(122, 162, 194, 0.22);
      backdrop-filter: blur(20px) saturate(1.2);
      -webkit-backdrop-filter: blur(20px) saturate(1.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.15),
        0 2px 8px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -1px 0 rgba(0, 0, 0, 0.1);
      display: block;
      opacity: 1;
      visibility: visible;
      overflow: hidden;
    }

    .chart-bar::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(
        135deg,
        rgba(255, 255, 255, 0.2) 0%,
        rgba(255, 255, 255, 0.1) 30%,
        rgba(255, 255, 255, 0.02) 70%,
        rgba(0, 0, 0, 0.05) 100%
      );
      border-radius: inherit;
      pointer-events: none;
      opacity: 0.8;
    }

    .chart-bar::after {
      content: "";
      position: absolute;
      top: 1px;
      left: 1px;
      right: 1px;
      height: 30%;
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.15) 0%,
        rgba(255, 255, 255, 0.05) 50%,
        transparent 100%
      );
      border-radius: 10px 10px 0 0;
      pointer-events: none;
    }
    @media (prefers-reduced-motion: no-preference) {
      .chart-bar:hover {
        background: rgba(122, 162, 194, 0.28);
        border-color: rgba(255, 255, 255, 0.25);
        box-shadow:
          0 12px 36px rgba(122, 162, 194, 0.25),
          0 4px 12px rgba(0, 0, 0, 0.15),
          inset 0 1px 0 rgba(255, 255, 255, 0.35);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .chart-bar:hover {
        background: rgba(122, 162, 194, 0.28);
        border-color: rgba(255, 255, 255, 0.25);
      }
    }
    .input-price-bar {
      background: rgba(34, 197, 94, 0.25);
      border-color: rgba(34, 197, 94, 0.4);
    }
    @media (prefers-reduced-motion: no-preference) {
      .input-price-bar:hover {
        background: rgba(34, 197, 94, 0.35);
        border-color: rgba(34, 197, 94, 0.5);
        box-shadow:
          0 12px 36px rgba(34, 197, 94, 0.25),
          0 4px 12px rgba(0, 0, 0, 0.15),
          inset 0 1px 0 rgba(255, 255, 255, 0.35);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .input-price-bar:hover {
        background: rgba(34, 197, 94, 0.35);
        border-color: rgba(34, 197, 94, 0.5);
      }
    }

    .output-price-bar {
      background: rgba(239, 68, 68, 0.25);
      border-color: rgba(239, 68, 68, 0.4);
    }
    @media (prefers-reduced-motion: no-preference) {
      .output-price-bar:hover {
        background: rgba(239, 68, 68, 0.35);
        border-color: rgba(239, 68, 68, 0.5);
        box-shadow:
          0 12px 36px rgba(239, 68, 68, 0.25),
          0 4px 12px rgba(0, 0, 0, 0.15),
          inset 0 1px 0 rgba(255, 255, 255, 0.35);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .output-price-bar:hover {
        background: rgba(239, 68, 68, 0.35);
        border-color: rgba(239, 68, 68, 0.5);
      }
    }

    .performance-bar {
      background: rgba(122, 162, 194, 0.22);
      border-color: rgba(122, 162, 194, 0.38);
    }
    @media (prefers-reduced-motion: no-preference) {
      .performance-bar:hover {
        background: rgba(122, 162, 194, 0.3);
        border-color: rgba(122, 162, 194, 0.5);
        box-shadow:
          0 12px 36px rgba(122, 162, 194, 0.25),
          0 4px 12px rgba(0, 0, 0, 0.15),
          inset 0 1px 0 rgba(255, 255, 255, 0.35);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .performance-bar:hover {
        background: rgba(122, 162, 194, 0.3);
        border-color: rgba(122, 162, 194, 0.5);
      }
    }
    .bar-value {
      position: absolute;
      top: -2rem;
      width: 100%;
      font-size: 0.8rem;
      font-weight: 900;
      color: #000000;
      text-align: center;
      padding: 0.4rem;
      text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
      line-height: 1.2;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 4px;
      margin-bottom: 0.5rem;
      z-index: 20;
      box-sizing: border-box;
    }
    .bar-label {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.92);
      font-weight: 800;
      text-align: center;
      word-wrap: break-word;
      white-space: normal;
      line-height: 1.15;
      max-width: 100%;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }
    .bar-label .bar-name {
      display: block;
    }
    .bar-label .bar-variant {
      display: block;
      font-weight: 600;
      opacity: 0.85;
      font-size: 0.8rem;
    }
    .insights-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
      margin-top: 2rem;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }
    .insight-card {
      background: var(--surface);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 4px;
      padding: 1.5rem;
      border: 2px solid var(--border-color);
      box-shadow: 4px 4px 0px var(--shadow-color);
      transition:
        transform 0.1s ease,
        box-shadow 0.1s ease;
    }
    html.light .insight-card {
      background: var(--surface);
      border: 2px solid var(--border-color);
      box-shadow: 4px 4px 0px var(--shadow-color);
    }
    @media (prefers-reduced-motion: no-preference) {
      .insight-card:hover {
        transform: translate(-2px, -2px);
        box-shadow: 6px 6px 0px var(--shadow-color);
        border-color: var(--border-color);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .insight-card:hover {
        border-color: var(--border-color);
      }
    }
    .insight-card h4 {
      margin: 0 0 0.5rem 0;
      font-size: 0.9rem;
      color: rgba(248, 248, 248, 0.7);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    html.light .insight-card h4 {
      color: #797593;
    }
    .insight-card p {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-primary);
    }
    html.light .insight-card p {
      color: #575279;
    }

    .no-data {
      text-align: center;
      color: #666;
      padding: 2rem;
      font-style: italic;
    }
    .search-container {
      margin-bottom: 0.75rem;
    }
    .model-search {
      background: var(--surface);
      border: 2px solid var(--border-color);
      box-shadow: 2px 2px 0px var(--shadow-color);
      border-radius: 4px;
      color: var(--text);
      padding: 0.625rem 1rem;
      width: 100%;
      font-size: 0.8rem;
      transition: all 0.1s ease;
      outline: none;
    }
    .model-search:focus {
      border-color: var(--border-color);
      background: var(--highlight-low);
      transform: translate(-1px, -1px);
      box-shadow: 3px 3px 0px var(--shadow-color);
    }
    .model-search::placeholder {
      color: #6e6a86;
    }
    html.light .model-search {
      background: var(--surface);
      border: 2px solid var(--border-color);
      color: var(--text);
    }
    html.light .model-search::placeholder {
      color: var(--muted);
    }
    .filter-toggle {
      position: fixed;
      left: 1rem;
      bottom: 1rem;
      z-index: 60;
      background: var(--surface);
      color: var(--text);
      border: 2px solid var(--border-color);
      box-shadow: 4px 4px 0px var(--shadow-color);
      border-radius: 4px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.1s ease;
    }

    .filter-toggle:hover {
      transform: translate(-2px, -2px);
      box-shadow: 6px 6px 0px var(--shadow-color);
      background: var(--highlight-low);
    }

    .filter-toggle:active {
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0px var(--shadow-color);
    }

    .filter-label {
      font-size: 1.2rem;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }

    .filter-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 40;
    }
    @media (max-width: 800px) {
      .layout {
        flex-direction: column;
        padding: 0;
        max-width: 100%;
      }
      .smart-filter-rail {
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: 85%;
        max-width: 320px;
        transform: translateX(-100%);
        z-index: 55;
        overflow-y: auto;
        background: rgba(0, 1, 0, 0.95);
        backdrop-filter: blur(20px);
        border-right: 1px solid rgba(255, 255, 255, 0.1);
        height: 100vh;
        margin-top: 0;
        padding: 1.5rem;
        transition: transform 0.3s ease;
      }
      .smart-filter-rail.open {
        transform: translateX(0);
        box-shadow: 0 4px 32px rgba(0, 0, 0, 0.6);
      }
      .compare-main {
        width: 100%;
        margin-left: 0;
        padding: 1rem;
      }
      .filter-toggle {
        display: block;
      }
      .filter-overlay.active {
        opacity: 1;
        pointer-events: auto;
      }
      .chart-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
      .insights-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 0.75rem;
      }
      .nav-content {
        padding: 1rem;
      }
      .chart-container {
        display: block;
        padding: 0.5rem;
        height: 320px;
        width: 100%;
      }
      .chart-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
        min-width: 50px;
        max-width: 70px;
      }
    }

    @media (max-width: 500px) {
      .insights-grid {
        grid-template-columns: 1fr;
      }
      .layout {
        margin: 1rem auto;
      }
      .filter-toggle {
        bottom: 5rem;
        left: 1rem;
        width: 42px;
        height: 42px;
        font-size: 0.9rem;
      }
      .chart-container {
        padding: 0.5rem;
        height: 300px;
      }
      .chart-item {
        min-width: 45px;
        max-width: 60px;
      }
    }
    .sort-toggle {
      background: var(--surface);
      border: 2px solid var(--border-color);
      box-shadow: 2px 2px 0px var(--shadow-color);
      border-radius: 4px;
      color: var(--text);
      padding: 0.625rem 1rem;
      width: 100%;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.1s ease;
      text-align: center;
      font-weight: 700;
      text-transform: uppercase;
    }
    .sort-toggle:hover {
      border-color: var(--border-color);
      background: var(--highlight-low);
      transform: translate(-1px, -1px);
      box-shadow: 3px 3px 0px var(--shadow-color);
    }
    html.light .sort-toggle {
      background: var(--surface);
      border: 2px solid var(--border-color);
      color: var(--text);
    }

    .metric-dropdown {
      background: var(--surface);
      border: 2px solid var(--border-color);
      box-shadow: 2px 2px 0px var(--shadow-color);
      border-radius: 4px;
      color: var(--text);
      padding: 0.625rem 1rem;
      width: 100%;
      font-size: 0.8rem;
      font-weight: 700;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.1s ease;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      background-size: 0.875rem;
      padding-right: 2.5rem;
    }

    .metric-dropdown:hover {
      border-color: var(--border-color);
      background-color: var(--highlight-low);
      transform: translate(-1px, -1px);
      box-shadow: 3px 3px 0px var(--shadow-color);
    }

    .metric-dropdown:focus {
      outline: none;
      border-color: var(--border-color);
      background-color: var(--highlight-med);
      box-shadow: 0 0 0 0px var(--shadow-color);
      transform: translate(2px, 2px);
    }

    .metric-dropdown option {
      background-color: var(--base);
      color: var(--text);
      padding: 10px;
    }

    html.light .metric-dropdown {
      background-color: var(--surface);
      border: 2px solid var(--border-color);
      color: var(--text);
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23000000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      background-size: 0.875rem;
    }

    .footer-wrapper {
      margin-left: 280px;
      width: calc(100% - 280px);
    }

    @media (max-width: 800px) {
      .footer-wrapper {
        margin-left: 0;
        width: 100%;
      }
    }

    /* View Transitions - Smooth page navigation */
    @media (prefers-reduced-motion: no-preference) {
      ::view-transition-old(root),
      ::view-transition-new(root) {
        animation-duration: 0.3s;
      }
    }

    /* Disable transitions for users who prefer reduced motion */
    @media (prefers-reduced-motion: reduce) {
      ::view-transition-old(root),
      ::view-transition-new(root) {
        animation: none;
      }
    }
  </style>
<div
  class="compare-container"
  style="overflow-x: hidden; width: 100%; max-width: 100vw;"
>
  <Header currentPage="compare" />

  <button
    class="filter-toggle"
    id="filter-toggle"
    aria-expanded="false"
    aria-label="Toggle filters"
  >
    <span class="filter-label">&lt;=&gt;</span>
  </button>
  <div class="filter-overlay" id="filter-overlay"></div>

  <div class="layout">
    <aside class="smart-filter-rail" id="smart-filter-rail">
      <div class="filter-section">
        <label for="metric-selector" class="filter-label">
          <h3>Performance Metric</h3>
        </label>
        <select
          id="metric-selector"
          class="metric-dropdown"
          aria-label="Select performance metric"
        >
          {
            Object.entries(availableBenchmarks).map(([value, label]) => (
              <option value={value} selected={value === "mmlu_pro"}>
                {label}
              </option>
            ))
          }
        </select>
      </div>
      <div class="filter-section">
        <h3>Sort Order</h3>
        <button id="sort-toggle" class="sort-toggle" data-order="desc">
          <span class="sort-text">High to Low</span>
        </button>
      </div>
      <div class="filter-section">
        <h3>Model Selection</h3>
        <div class="search-container">
          <input
            type="text"
            id="model-search"
            placeholder="Search models..."
            class="model-search"
          />
        </div>
        <div class="selected-count"></div>
        <div class="model-list"></div>
      </div>
    </aside>

    <main class="compare-main">
      <section class="charts-section">
        <div class="chart-grid">
          <div class="chart-section">
            <div class="chart-header">
              <h3>Price Comparison</h3>
            </div>
            <div class="chart-container" id="price-chart">
              <canvas id="price-canvas"></canvas>
            </div>
          </div>

          <div class="chart-section">
            <div class="chart-header">
              <h3>Performance Comparison</h3>
            </div>
            <div class="chart-container" id="performance-chart">
              <canvas id="perf-canvas"></canvas>
            </div>
          </div>
        </div>
      </section>

      <section class="insights-section">
        <div class="insights-grid">
          <div class="insight-card">
            <h4>Cheapest Tokens</h4>
            <p>{cheapestTokensModel ? cheapestTokensModel.name : "—"}</p>
          </div>
          <div class="insight-card">
            <h4>Cheapest Input</h4>
            <p>{inputPriceWinner ? inputPriceWinner.name : "—"}</p>
          </div>
          <div class="insight-card">
            <h4>Cheapest Output</h4>
            <p>{outputPriceWinner ? outputPriceWinner.name : "—"}</p>
          </div>
          <div class="insight-card">
            <h4>Highest TPS</h4>
            <p>{tpsWinner ? tpsWinner.name : "—"}</p>
          </div>
          <div class="insight-card">
            <h4>Fastest TTFT</h4>
            <p>{ttftWinner ? ttftWinner.name : "—"}</p>
          </div>
          <div class="insight-card">
            <h4 id="performance-metric-title">Top MMLU Pro</h4>
            <p>{performanceWinner ? performanceWinner.name : "—"}</p>
          </div>
          <div class="insight-card">
            <h4 style="color: var(--iris);">Top GPQA Diamond</h4>
            <p>
              {
                topGpqaDiamond
                  ? topGpqaDiamond.model_version.replace(/_/g, " ")
                  : "—"
              }
            </p>
            <span style="font-size: 0.65rem; color: var(--muted);"
              >{
                topGpqaDiamond
                  ? `${(topGpqaDiamond.score! * 100).toFixed(1)}%`
                  : ""
              }</span
            >
          </div>
          <div class="insight-card">
            <h4 style="color: var(--iris);">Top FrontierMath</h4>
            <p>
              {
                topFrontierMath
                  ? topFrontierMath.model_version.replace(/_/g, " ")
                  : "—"
              }
            </p>
            <span style="font-size: 0.65rem; color: var(--muted);"
              >{
                topFrontierMath
                  ? `${(topFrontierMath.score! * 100).toFixed(1)}%`
                  : ""
              }</span
            >
          </div>
        </div>
      </section>
    </main>
  </div>
</div>

<div class="footer-wrapper">
  <Footer />
</div>
<ScrollToTop />

<script
  is:inline
  define:vars={{
    validModels: initialClientModels,
    epochScoresByModel: initialClientEpochScores,
    availableBenchmarks,
  }}
>
  // Security: HTML sanitization function to prevent XSS attacks
  function sanitizeHTML(str) {
    const div = document.createElement("div");
    div.textContent = str || "";
    return div.innerHTML;
  }

  const cleanupEffects = [];
  const registerCleanup = (fn) => {
    if (typeof fn === "function") cleanupEffects.push(fn);
  };
  const runCleanup = () => {
    while (cleanupEffects.length) {
      const cleanup = cleanupEffects.pop();
      try {
        cleanup();
      } catch (error) {
        console.warn("Cleanup failed", error);
      }
    }
  };

  const destroyChartForCanvas = (canvas) => {
    if (!canvas || !window.Chart) return;
    const existing =
      typeof window.Chart.getChart === "function"
        ? window.Chart.getChart(canvas)
        : null;
    if (existing && typeof existing.destroy === "function") {
      existing.destroy();
    }
  };

  // Dynamically ensure Chart.js is available (in case CDN is blocked)
  let __chartLibLoading = null;
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const existing = document.querySelector(
        `script[data-loaded-src="${src}"]`,
      );
      if (existing) {
        if (existing.dataset.loaded === "true") {
          resolve();
        } else {
          existing.addEventListener("load", resolve, { once: true });
          existing.addEventListener("error", reject, { once: true });
        }
        return;
      }

      const s = document.createElement("script");
      s.src = src;
      s.async = false;
      s.defer = false;
      s.dataset.loadedSrc = src;
      s.addEventListener(
        "load",
        () => {
          s.dataset.loaded = "true";
          resolve();
        },
        { once: true },
      );
      s.addEventListener("error", reject, { once: true });
      document.head.appendChild(s);
    });
  }
  async function ensureChartLibs() {
    if (window.Chart && (window.ChartDataLabels || window["ChartDataLabels"]))
      return true;
    if (!__chartLibLoading) {
      __chartLibLoading = (async () => {
        if (!window.Chart) {
          await loadScript(
            "https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js",
          );
        }
        if (!(window.ChartDataLabels || window["ChartDataLabels"])) {
          await loadScript(
            "https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js",
          );
        }
        return true;
      })();
    }
    return __chartLibLoading;
  }

  async function initCompare() {
    // Initialize sidebar state based on screen size
    const initializeLayout = () => {
      const isMobile = window.innerWidth <= 800;
      const rail = document.getElementById("smart-filter-rail");
      const main = document.querySelector(".compare-main");
      const toggle = document.getElementById("filter-toggle");
      const label = toggle?.querySelector(".filter-label");

      if (isMobile) {
        rail?.classList.remove("closed");
        rail?.classList.remove("open");
        if (label) label.innerHTML = "&lt;=&gt;";
      } else {
        // Default to showing sidebar on desktop
        rail?.classList.remove("closed");
        if (main) {
          main.style.marginLeft = "280px";
          main.style.width = "calc(100% - 280px)";
        }
        if (label) label.innerHTML = "&times;";
      }
    };

    // Call initially and on resize
    initializeLayout();
    window.addEventListener("resize", initializeLayout);
    registerCleanup(() =>
      window.removeEventListener("resize", initializeLayout),
    );

    const toggle = document.getElementById("filter-toggle");
    const rail = document.getElementById("smart-filter-rail");
    const overlay = document.getElementById("filter-overlay");

    function closeFilters() {
      const isMobile = window.innerWidth <= 800;

      if (isMobile) {
        rail.classList.remove("open");
        overlay.classList.remove("active");
        toggle.setAttribute("aria-expanded", "false");
        const label = toggle.querySelector(".filter-label");
        if (label) label.innerHTML = "&lt;=&gt;";
      } else {
        rail.classList.add("closed");
        toggle.setAttribute("aria-expanded", "false");
        const label = toggle.querySelector(".filter-label");
        if (label) label.innerHTML = "&lt;=&gt;";

        // Adjust main content area
        const main = document.querySelector(".compare-main");
        if (main) {
          main.style.marginLeft = "0";
          main.style.width = "100%";
        }
      }
    }

    toggle?.addEventListener("click", () => {
      // For mobile, we use 'open' class to show the sidebar
      // For desktop, we use 'closed' class to hide the sidebar
      const isMobile = window.innerWidth <= 800;

      if (isMobile) {
        const isOpen = rail.classList.toggle("open");
        overlay.classList.toggle("active", isOpen);
        toggle.setAttribute("aria-expanded", isOpen.toString());
        const label = toggle.querySelector(".filter-label");
        if (label) label.innerHTML = isOpen ? "&times;" : "&lt;=&gt;";
      } else {
        const isClosed = rail.classList.toggle("closed");
        toggle.setAttribute("aria-expanded", (!isClosed).toString());
        const label = toggle.querySelector(".filter-label");
        if (label) label.innerHTML = isClosed ? "&lt;=&gt;" : "&times;";

        // Also adjust the main content area when sidebar is toggled
        const main = document.querySelector(".compare-main");
        if (main) {
          main.style.marginLeft = isClosed ? "0" : "280px";
          main.style.width = isClosed ? "100%" : "calc(100% - 280px)";
        }
      }
    });

    overlay?.addEventListener("click", closeFilters);

    // Dynamic model selection and charts
    let modelsState = [...validModels];
    let filteredModels = [...modelsState]; // For search filtering
    const selected = new Set(modelsState.slice(0, 3).map((m) => m.id));
    const list = document.querySelector(".model-list");
    const countEl = document.querySelector(".selected-count");
    const priceChart = document.getElementById("price-chart");
    const perfChart = document.getElementById("performance-chart");
    const priceCanvas = document.getElementById("price-canvas");
    const perfCanvas = document.getElementById("perf-canvas");
    let priceChartInstance = null;
    let perfChartInstance = null;
    const metricSelector = document.getElementById("metric-selector");
    const performanceMetricTitle = document.getElementById(
      "performance-metric-title",
    );

    // Benchmark display names and epoch scores (mutable for live refresh)
    let benchmarkNames = { ...availableBenchmarks };
    let epochScores = { ...epochScoresByModel };
    let epochAliasesByVersion = {};
    let epochRunsState = [];
    let epochBenchmarksState = [];
    const sortToggle = document.getElementById("sort-toggle");
    const searchInput = document.getElementById("model-search");

    const normalizeModelKey = (value) =>
      String(value || "")
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, " ")
        .trim();

    const collectLookupKeys = (model) => {
      const keys = new Set();
      const tokenSources = [];
      const register = (candidate) => {
        const normalized = normalizeModelKey(candidate);
        if (!normalized) return;
        keys.add(normalized);
        keys.add(normalized.replace(/\s+/g, ""));
        tokenSources.push(normalized);
      };

      register(model?.name);
      register(model?.slug);

      const normalizedName = normalizeModelKey(model?.name);
      const normalizedCompany = normalizeModelKey(model?.company_name);
      if (
        normalizedName &&
        normalizedCompany &&
        normalizedName.startsWith(`${normalizedCompany} `)
      ) {
        register(normalizedName.slice(normalizedCompany.length).trim());
      }

      const tokens = Array.from(new Set(tokenSources.join(" ").split(" "))).filter(
        (token) => token && token.length > 2,
      );

      return {
        keys: Array.from(keys).filter(Boolean),
        tokens,
      };
    };

    const rebuildEpochAliasesByVersion = (models) => {
      const aliasesByVersion = {};
      (models || []).forEach((model) => {
        if (!model?.model_version) return;
        const aliases = new Set();
        [model.model_version, model.model_name, model.display_name].forEach(
          (candidate) => {
            const normalized = normalizeModelKey(candidate);
            if (!normalized) return;
            aliases.add(normalized);
            aliases.add(normalized.replace(/\s+/g, ""));
          },
        );
        if (aliases.size > 0) {
          aliasesByVersion[model.model_version] = Array.from(aliases);
        }
      });
      return aliasesByVersion;
    };

    const AA_BENCHMARK_NAMES = {
      mmlu_pro: "MMLU Pro",
      gpqa: "GPQA",
      hle: "HumanEval",
      aa_math_index: "Math Index",
      aa_coding_index: "Coding Index",
      aa_intelligence_index: "Intelligence Index",
      livecodebench: "LiveCodeBench",
      scicode: "SciCode",
      math_500: "Math 500",
      aime: "AIME",
      elo: "ELO Rating",
    };

    const updateMetricSelectorOptions = () => {
      if (!metricSelector) return;
      const previousValue = metricSelector.value || "mmlu_pro";
      const options = Object.entries(benchmarkNames).map(
        ([value, label]) =>
          `<option value="${value}">${sanitizeHTML(label)}</option>`,
      );
      metricSelector.innerHTML = options.join("");
      metricSelector.value = benchmarkNames[previousValue]
        ? previousValue
        : Object.keys(benchmarkNames)[0] || "mmlu_pro";
    };

    const rebuildEpochScores = (runs, aliasesByVersion = {}) => {
      const byAlias = {};
      const registerScore = (aliasKey, benchmarkSlug, score) => {
        if (!aliasKey || !benchmarkSlug || !Number.isFinite(score)) return;
        if (!byAlias[aliasKey]) byAlias[aliasKey] = {};
        byAlias[aliasKey][benchmarkSlug] = score;
      };

      runs.forEach((run) => {
        if (!run.model_version || run.score === null || !run.benchmark_slug)
          return;
        const normalizedVersion = normalizeModelKey(run.model_version);
        const aliases = new Set([
          normalizedVersion,
          normalizedVersion.replace(/\s+/g, ""),
          ...((aliasesByVersion[run.model_version] || []).filter(Boolean) || []),
        ]);
        aliases.forEach((alias) => {
          registerScore(alias, run.benchmark_slug, Number(run.score) || 0);
        });
      });
      return byAlias;
    };

    const resolveMetricScore = (model, metricKey) => {
      if (!metricKey.startsWith("epoch_")) {
        return Number(model?.[metricKey]) || 0;
      }

      const epochSlug = metricKey.replace("epoch_", "");
      const { keys, tokens } = collectLookupKeys(model);

      for (const key of keys) {
        const exactScore = Number(epochScores?.[key]?.[epochSlug]);
        if (Number.isFinite(exactScore) && exactScore > 0) {
          return exactScore <= 1 ? exactScore * 100 : exactScore;
        }
      }

      let fallbackScore = 0;
      if (tokens.length > 0) {
        Object.entries(epochScores).forEach(([alias, scores]) => {
          if (!tokens.every((token) => alias.includes(token))) return;
          const score = Number(scores?.[epochSlug]);
          if (Number.isFinite(score) && score > fallbackScore) {
            fallbackScore = score;
          }
        });
      }

      return fallbackScore <= 1 ? fallbackScore * 100 : fallbackScore;
    };

    const rebuildBenchmarkNames = (benchmarks, runs) => {
      const names = { ...AA_BENCHMARK_NAMES };
      const withData = benchmarks.filter((benchmark) =>
        runs.some(
          (run) => run.benchmark_slug === benchmark.slug && run.score !== null,
        ),
      );
      withData.forEach((benchmark) => {
        names[`epoch_${benchmark.slug}`] = `${benchmark.name} (Epoch)`;
      });
      return names;
    };

    function applyFiltersAndSort() {
      const searchTerm = searchInput ? searchInput.value.toLowerCase() : "";

      // Filter by search term only
      filteredModels = modelsState.filter((model) =>
        (model.name || "").toLowerCase().includes(searchTerm),
      );
    }

    function renderModelList() {
      if (!list) return;
      applyFiltersAndSort();

      list.innerHTML = filteredModels
        .map(
          (m) => `
            <div class="model-item">
              <input type="checkbox" id="model-${m.id}" data-id="${m.id}" ${selected.has(m.id) ? "checked" : ""} />
              <label for="model-${m.id}">${sanitizeHTML(m.name || "Unknown model")}</label>
            </div>
          `,
        )
        .join("");
    }

    function updateCount() {
      if (countEl)
        countEl.textContent = `${selected.size} of ${filteredModels.length} models selected`;
    }

    function getSelected() {
      return modelsState.filter((m) => selected.has(m.id));
    }

    function updateInsights(models) {
      if (models.length === 0) return;

      // Find cheapest tokens model (lowest blended price)
      let cheapestTokensModel = null;
      let lowestBlendedPrice = Infinity;

      // Find cheapest input, output, top performer, TPS winner, and TTFT winner for current metric
      let cheapestInputModel = models[0];
      let cheapestOutputModel = models[0];
      let topPerformerModel = models[0];
      let tpsWinnerModel = null;
      let ttftWinnerModel = null;
      let highestTPS = 0;
      let fastestTTFT = Infinity;

      const currentMetric = metricSelector?.value || "mmlu_pro";

      models.forEach((model) => {
        // Find model with lowest blended price
        const blendedPrice = model.price_1m_blended_3_to_1;
        const priceNum = parseFloat(blendedPrice);

        if (
          blendedPrice !== null &&
          blendedPrice !== undefined &&
          !isNaN(priceNum) &&
          priceNum > 0 &&
          priceNum < lowestBlendedPrice
        ) {
          lowestBlendedPrice = priceNum;
          cheapestTokensModel = model;
        }

        if (
          (Number(model.price_1m_input_tokens) || Infinity) <
          (Number(cheapestInputModel.price_1m_input_tokens) || Infinity)
        ) {
          cheapestInputModel = model;
        }

        if (
          (Number(model.price_1m_output_tokens) || Infinity) <
          (Number(cheapestOutputModel.price_1m_output_tokens) || Infinity)
        ) {
          cheapestOutputModel = model;
        }

        if (
          resolveMetricScore(model, currentMetric) >
          resolveMetricScore(topPerformerModel, currentMetric)
        ) {
          topPerformerModel = model;
        }

        // Find TPS winner (highest tokens per second)
        const modelTPS = model.median_output_tokens_per_second;
        const winnerTpsNum = parseFloat(modelTPS);
        if (
          modelTPS !== null &&
          modelTPS !== undefined &&
          !isNaN(winnerTpsNum) &&
          winnerTpsNum > 0 &&
          winnerTpsNum > highestTPS
        ) {
          highestTPS = winnerTpsNum;
          tpsWinnerModel = model;
        }

        // Find TTFT winner (fastest time to first token - lower is better)
        const modelTTFT = model.median_time_to_first_answer_token;
        const ttftNum = parseFloat(modelTTFT);
        if (
          modelTTFT !== null &&
          modelTTFT !== undefined &&
          !isNaN(ttftNum) &&
          ttftNum > 0 &&
          ttftNum < fastestTTFT
        ) {
          fastestTTFT = ttftNum;
          ttftWinnerModel = model;
        }
      });

      // Update the insight cards
      const insightCards = document.querySelectorAll(".insight-card p");
      if (insightCards.length >= 6) {
        insightCards[0].textContent = cheapestTokensModel
          ? cheapestTokensModel.name
          : "—";
        insightCards[1].textContent = cheapestInputModel.name;
        insightCards[2].textContent = cheapestOutputModel.name;
        insightCards[3].textContent = tpsWinnerModel
          ? tpsWinnerModel.name
          : "—";
        insightCards[4].textContent = ttftWinnerModel
          ? ttftWinnerModel.name
          : "—";
        insightCards[5].textContent = topPerformerModel.name;
      }
    }

    function renderCharts() {
      let chosen = getSelected();

      // Ensure chart containers exist (metric selector is optional)
      if (!priceChart || !perfChart) {
        console.error("Chart elements not found");
        return;
      }

      // Update insights section
      updateInsights(chosen);

      // Clear any existing "no data" messages but preserve the container structure
      const existingNoData = priceChart.querySelector(".no-data");
      if (existingNoData) existingNoData.remove();

      if (chosen.length === 0) {
        // Add "no data" message without clearing the container
        if (!priceChart.querySelector(".no-data")) {
          const noDataEl = document.createElement("div");
          noDataEl.className = "no-data";
          noDataEl.style.cssText =
            "text-align: center; color: #666; padding: 2rem;";
          noDataEl.textContent = "Select models to compare";
          priceChart.appendChild(noDataEl);
        }

        if (!perfChart.querySelector(".no-data")) {
          const noDataEl = document.createElement("div");
          noDataEl.className = "no-data";
          noDataEl.style.cssText =
            "text-align: center; color: #666; padding: 2rem;";
          noDataEl.textContent = "Select models to compare";
          perfChart.appendChild(noDataEl);
        }
        return;
      }

      // Get sort order and metric
      const sortOrder = sortToggle
        ? sortToggle.getAttribute("data-order")
        : "desc";
      const metric = metricSelector ? metricSelector.value : "mmlu_pro";

      // Update performance chart title with benchmark name
      const perfChartHeader = document
        .querySelector("#performance-chart")
        .parentElement.querySelector(".chart-header h3");
      if (perfChartHeader) {
        const benchmarkName =
          benchmarkNames[metric] || metric.toUpperCase().replace("_", " ");
        perfChartHeader.textContent = `${benchmarkName} Performance Comparison`;
      }

      // Do not clear containers; destroy existing chart instances instead
      destroyChartForCanvas(priceCanvas);
      destroyChartForCanvas(perfCanvas);
      if (priceChartInstance) {
        priceChartInstance.destroy();
        priceChartInstance = null;
      }
      if (perfChartInstance) {
        perfChartInstance.destroy();
        perfChartInstance = null;
      }

      // Sort chosen models by price for price chart
      const chosenByPrice = [...chosen].sort((a, b) => {
        const totalA =
          (Number(a.price_1m_input_tokens) || 0) +
          (Number(a.price_1m_output_tokens) || 0);
        const totalB =
          (Number(b.price_1m_input_tokens) || 0) +
          (Number(b.price_1m_output_tokens) || 0);
        return sortOrder === "desc" ? totalB - totalA : totalA - totalB;
      });

      // Calculate dynamic gap based on number of models
      const numModels = chosenByPrice.length;
      const showPriceLabels = numModels <= 8;
      const dynamicGap = numModels > 6 ? "0.5rem" : "1rem";

      // Update container gap for this render
      if (priceChart.parentElement) {
        priceChart.parentElement.style.gap = dynamicGap;
      }

      // Ensure canvases have concrete pixel sizes
      if (priceCanvas) {
        const pr = priceChart.getBoundingClientRect();
        priceCanvas.width = Math.max(
          300,
          priceChart.clientWidth || pr.width || 600,
        );
        priceCanvas.height = Math.max(
          200,
          priceChart.clientHeight || pr.height || 360,
        );
      }
      if (perfCanvas) {
        const rr = perfChart.getBoundingClientRect();
        perfCanvas.width = Math.max(
          300,
          perfChart.clientWidth || rr.width || 600,
        );
        perfCanvas.height = Math.max(
          200,
          perfChart.clientHeight || rr.height || 360,
        );
      }

      // Build price chart using Chart.js
      const labelParts = (name) => {
        const m = name.match(/^(.*?)(\s*\(([^)]*)\))?$/);
        const base = m ? m[1] : name;
        const variant = m && m[3] ? m[3] : "";
        return variant ? [base, `(${variant})`] : [base];
      };
      const priceLabels = chosenByPrice.map((m) => labelParts(m.name));
      const inputData = chosenByPrice.map(
        (m) => Number(m.price_1m_input_tokens) || 0,
      );
      const outputData = chosenByPrice.map(
        (m) => Number(m.price_1m_output_tokens) || 0,
      );
      if (priceCanvas && window.Chart) {
        window.Chart.register(
          window.ChartDataLabels || window["ChartDataLabels"],
        );
        priceChartInstance = new window.Chart(priceCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: priceLabels,
            datasets: [
              {
                label: "Input",
                data: inputData,
                backgroundColor: "rgba(34,197,94,0.35)",
                borderColor: "rgba(34,197,94,0.6)",
                borderWidth: 1,
                borderRadius: 10,
              },
              {
                label: "Output",
                data: outputData,
                backgroundColor: "rgba(239,68,68,0.35)",
                borderColor: "rgba(239,68,68,0.6)",
                borderWidth: 1,
                borderRadius: 10,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: "index", intersect: false },
            plugins: {
              legend: {
                position: "bottom",
                labels: { color: "#eae9f0" },
              },
              tooltip: {
                enabled: true,
                position: "nearest",
                yAlign: "bottom",
                displayColors: true,
                backgroundColor: "rgba(0, 0, 0, 0.9)",
                titleColor: "#fff",
                bodyColor: "#fff",
                borderColor: "rgba(156, 207, 216, 0.5)",
                borderWidth: 1,
                padding: 12,
                callbacks: {
                  label: (ctx) =>
                    `${ctx.dataset.label}: $${(ctx.parsed.y ?? 0).toFixed(3)} per 1M`,
                },
              },
              datalabels: {
                anchor: "end",
                align: "end",
                color: "#111",
                backgroundColor: "rgba(255,255,255,0.9)",
                borderRadius: 4,
                padding: 6,
                font: { weight: "900", size: 11 },
                offset: -4,
                clamp: true,
                clip: false,
                display: showPriceLabels,
                formatter: (v) => `${v >= 10 ? v.toFixed(1) : v.toFixed(2)}`,
              },
            },
            scales: {
              x: {
                ticks: {
                  color: "#eae9f0",
                  maxRotation: 45,
                  minRotation: 45,
                },
                grid: { display: false },
              },
              y: {
                beginAtZero: true,
                suggestedMax: Math.max(...inputData, ...outputData) * 1.2,
                ticks: {
                  color: "#eae9f0",
                  callback: (v) => `$${Number(v).toFixed(0)}`,
                },
                grid: {
                  color: "rgba(255,255,255,0.08)",
                  drawBorder: false,
                },
              },
            },
            layout: {
              padding: { top: 48, bottom: 8, left: 8, right: 8 },
            },
          },
          plugins: [window.ChartDataLabels || window["ChartDataLabels"]],
        });
      }

      // Sort chosen models by selected metric for performance chart
      const chosenByMetric = [...chosen].sort((a, b) => {
        const scoreA = resolveMetricScore(a, metric);
        const scoreB = resolveMetricScore(b, metric);
        return sortOrder === "desc" ? scoreB - scoreA : scoreA - scoreB;
      });

      // Build performance chart using Chart.js
      const perfLabels = chosenByMetric.map((m) => labelParts(m.name));
      const scores = chosenByMetric.map((m) => resolveMetricScore(m, metric));
      const showPerfLabels = chosenByMetric.length <= 8;
      if (perfCanvas && window.Chart) {
        window.Chart.register(
          window.ChartDataLabels || window["ChartDataLabels"],
        );
        const maxScore = scores.length ? Math.max(...scores) : 0;
        perfChartInstance = new window.Chart(perfCanvas.getContext("2d"), {
          type: "bar",
          data: {
            labels: perfLabels,
            datasets: [
              {
                label: "Score",
                data: scores,
                backgroundColor: "rgba(122,162,194,0.35)",
                borderColor: "rgba(122,162,194,0.6)",
                borderWidth: 1,
                borderRadius: 10,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const y = ctx.parsed.y ?? 0;
                    if (!Number.isFinite(y) || y <= 0) return "N/A";
                    const t = Math.trunc(y * 1000) / 1000; // truncate, no rounding
                    return `${t.toFixed(3)}%`;
                  },
                },
              },
              datalabels: {
                anchor: "end",
                align: "end",
                color: "#111",
                backgroundColor: "rgba(255,255,255,0.9)",
                borderRadius: 4,
                padding: 4,
                font: { weight: "900" },
                clip: false,
                clamp: true,
                offset: -4,
                display: showPerfLabels,
                formatter: (v) => {
                  if (!Number.isFinite(Number(v)) || Number(v) <= 0) return "N/A";
                  const t = Math.trunc(Number(v) * 1000) / 1000; // truncate
                  return `${t.toFixed(3)}%`;
                },
              },
            },
            scales: {
              x: {
                ticks: {
                  color: "#eae9f0",
                  maxRotation: 45,
                  minRotation: 45,
                },
                grid: { display: false },
              },
              y: {
                beginAtZero: true,
                suggestedMax: maxScore * 1.2,
                ticks: {
                  color: "#eae9f0",
                  callback: (v) => `${Number(v).toFixed(3)}%`,
                },
                grid: {
                  color: "rgba(255,255,255,0.08)",
                  drawBorder: false,
                },
              },
            },
            layout: { padding: { top: 32 } },
          },
          plugins: [window.ChartDataLabels || window["ChartDataLabels"]],
        });
      }
    }

    list?.addEventListener("change", (e) => {
      const target = e.target;
      if (target instanceof HTMLInputElement && target.dataset.id) {
        target.checked
          ? selected.add(target.dataset.id)
          : selected.delete(target.dataset.id);
        updateCount();
        renderCharts();
      }
    });

    // Metric selector change handler (consolidated)
    metricSelector?.addEventListener("change", async () => {
      // Update the performance metric title
      const selectedMetric = metricSelector.value;
      const displayName = benchmarkNames[selectedMetric] || selectedMetric;
      if (performanceMetricTitle) {
        performanceMetricTitle.textContent = `Top ${displayName}`;
      }

      // Re-render charts with new metric
      renderCharts();
    });

    // Add event listeners for new features
    searchInput?.addEventListener("input", () => {
      renderModelList();
      updateCount();
    });

    // Sort toggle functionality
    sortToggle?.addEventListener("click", () => {
      if (sortToggle) {
        const currentOrder = sortToggle.getAttribute("data-order");
        const newOrder = currentOrder === "desc" ? "asc" : "desc";
        sortToggle.setAttribute("data-order", newOrder);
        const textEl = sortToggle.querySelector(".sort-text");
        if (textEl) {
          textEl.textContent =
            newOrder === "desc" ? "High to Low" : "Low to High";
        }
        renderCharts(); // Only re-render charts, not model list
      }
    });

    window.addEventListener("aistats:live-snapshot", (event) => {
      const snapshot = event.detail;
      if (!snapshot) return;

      const nextModels = (snapshot.aaModels ?? []).filter((model) => {
        const inputPrice = Number(model.price_1m_input_tokens);
        const outputPrice = Number(model.price_1m_output_tokens);
        return inputPrice > 0 && outputPrice > 0;
      });

      modelsState = nextModels;
      epochRunsState = [...(snapshot.epochRuns ?? [])];
      epochBenchmarksState = [...(snapshot.epochBenchmarks ?? [])];
      epochAliasesByVersion = rebuildEpochAliasesByVersion(
        snapshot.epochModels ?? [],
      );
      epochScores = rebuildEpochScores(epochRunsState, epochAliasesByVersion);
      benchmarkNames = rebuildBenchmarkNames(
        epochBenchmarksState,
        epochRunsState,
      );
      updateMetricSelectorOptions();

      const liveIds = new Set(modelsState.map((model) => model.id));
      Array.from(selected).forEach((id) => {
        if (!liveIds.has(id)) selected.delete(id);
      });
      if (selected.size === 0) {
        modelsState.slice(0, 3).forEach((model) => selected.add(model.id));
      }

      renderModelList();
      updateCount();
      renderCharts();
    });

    updateMetricSelectorOptions();
    renderModelList();
    updateCount();
    try {
      await ensureChartLibs();
    } catch (e) {
      console.error("Failed to load chart libraries", e);
    }
    renderCharts();
  }

  // Auto-fit functionality for charts
  function initAutoFit() {
    const priceChart = document.getElementById("price-chart");
    const perfChart = document.getElementById("performance-chart");

    function fitModelsToChart(chart) {
      if (!chart) return;

      const chartItems = chart.querySelectorAll(".chart-item");
      if (!chartItems.length) return;

      // Calculate the minimum width needed to fit all items
      const totalItems = chartItems.length;
      const containerWidth = chart.clientWidth;
      // Account for gap between items (0.75rem = ~12px) and ensure all fit
      const totalGapWidth = (totalItems - 1) * 12;
      const availableWidth = containerWidth - totalGapWidth - 10; // 10px buffer
      const minItemWidth = Math.max(
        20,
        Math.floor(availableWidth / totalItems),
      );

      // Apply the calculated width to all items
      chartItems.forEach((item) => {
        item.style.minWidth = minItemWidth + "px";
        item.style.maxWidth = minItemWidth + "px";
        item.style.flex = "0 0 auto";

        // Improve overlapping names: allow up to 2 lines with ellipsis
        const label = item.querySelector(".bar-label");
        if (label) {
          label.style.maxWidth = minItemWidth + "px";
          label.style.overflow = "hidden";
          label.style.display = "-webkit-box";
          label.style.webkitBoxOrient = "vertical";
          label.style.webkitLineClamp = "2";
          label.setAttribute("title", label.textContent || "");
        }
      });

      // Center items in the container
      chart.style.justifyContent = "center";
    }

    // Apply auto-fit when charts are rendered
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" && mutation.addedNodes.length > 0) {
          if (mutation.target === priceChart || mutation.target === perfChart) {
            fitModelsToChart(mutation.target);
          }
        }
      });
    });
    registerCleanup(() => observer.disconnect());

    // Observe both charts for changes
    if (priceChart) {
      observer.observe(priceChart, { childList: true });
      // Initial fit if chart already has content
      fitModelsToChart(priceChart);
    }

    if (perfChart) {
      observer.observe(perfChart, { childList: true });
      // Initial fit if chart already has content
      fitModelsToChart(perfChart);
    }

    // Re-fit on window resize
    const handleResize = () => {
      fitModelsToChart(priceChart);
      fitModelsToChart(perfChart);
    };
    window.addEventListener("resize", handleResize);
    registerCleanup(() => window.removeEventListener("resize", handleResize));
  }

  // Initialize on both initial load and after view transitions
  function initialize() {
    runCleanup();
    initCompare();
    initAutoFit();
  }

  // Handle initial page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initialize);
  } else {
    initialize();
  }

  // Handle Astro View Transitions - re-initialize after navigation
  document.addEventListener("astro:page-load", initialize);
</script>
<script>
  import { fetchLiveSnapshot } from "../lib/live-data";

  const scheduleLiveRefresh = () => {
    const run = async () => {
      const snapshot = await fetchLiveSnapshot();
      if (!snapshot) return;
      window.dispatchEvent(
        new CustomEvent("aistats:live-snapshot", { detail: snapshot }),
      );
    };

    if ("requestIdleCallback" in window) {
      window.requestIdleCallback(
        () => {
          void run();
        },
        { timeout: 7000 },
      );
    } else {
      setTimeout(() => {
        void run();
      }, 3500);
    }
  };

  if (document.readyState === "complete") {
    scheduleLiveRefresh();
  } else {
    window.addEventListener("load", scheduleLiveRefresh, { once: true });
  }
</script>
</Layout>
